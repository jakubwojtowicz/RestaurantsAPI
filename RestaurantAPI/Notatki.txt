########################################################################################################################################################################################################################################################
Utworzenie migracji i zaktualizowanie bazy danych:

add-migration <Nazwa>

update-database



########################################################################################################################################################################################################################################################

Dependency Injection:

* Dodanie zale¿noœci Dependency Injection
* AddSingleton - mamy pewnoœæ, ¿e dana zale¿noœæ zosta³a utworzona tylko raz podczas trwania aplikacji.
* AddScoped - na jedno zapytanie bêdziemy mieæ jedn¹ instancje danego serwisu            
* AddTransient - obiekty bêd¹ tworzone za ka¿dym razem, kiedy odwo³ujemy siê do nich przez konstruktor.

services.AddScoped<IWeatherForecastService, WeatherForecastService>();

Dodajemy te zale¿noœci w metodzie ConfigureServices.

########################################################################################################################################################################################################################################################

ATRYBUTY

[Route("api/restaurant")]

To jest atrybut kontrolera, który s³u¿y do tego aby mo¿liwe by³o po³¹czenie zapytania z odpowiedni¹ akcj¹.
Dziêki temu, ¿e dodaliœmy api/restaruant, mo¿emy dodawaæ te¿ inne kontrolery, a nie tylko restaurant.

 * Dziêki atrybutowi Route mo¿emy dodaæ kolejny Get do naszego kontrolera. Bez tego by³by wyj¹tek, poniewa¿
 * program musi wiedzieæ do czego ma siê odnieœæ przy zapytaniu. 
        [HttpGet]
        [Route("currentDay")] ->  /weatherforecast/currentDay


 * Inna metod¹ zmiany œcie¿ki akcji jest dodanie argumentu do atrybutu HttpGet: [HttpGet("currentDay")]

########################################################################################################################################################################################################################################################

MAPOWANIE ARGUMENTOW ZAPYTAN

 * Mapowanie atrybutów, przesy³anie parametrów do akcji.
 * Dla parametró w nawiasach w metodach musimy sprecyzowaæ, sk¹d dany parametr pochodzi.
 * Parametr mo¿e pochodziæ z adresu zapytania lub z cia³a zapytania.
 * FromRoute - przekazanie poprzez œcie¿ke -> [Route("currentDay/{max}")]
 * FromQuery - przekazanie poprzez zapytanie
 * FromBody - poprzez cia³o zapytania na przyk³ad: ([FromBody] string name)
 * Parametry trzeba odpowiednio zmapowaæ, tak aby program wiedzia³ jak po³¹czyæ zapytanie z odpowiedni¹ akcj¹
 
 Sposoby zwracania statusów zapytania
 Http context to w³asnoœæ kontrolera, dziêki której mamy dostêp do zapytania jak i odpoweidzi Http


 Aby metoda zwraca³a kod musi mieæ typ taki typ zwracanej wartoœci:

    public ActionResult<string> Hello2([FromBody] string name)
    {
            HttpContext.Response.StatusCode = 401; -> pierwszy sposób 
            return $"Hello {name}"; 
            return StatusCode(401, $"Hello {name}"); -> drugi sposób Status Code
            return NotFound($"Hello {name}"); ->trzeci sposób poprzez zwrocenie metody
    }

########################################################################################################################################################################################################################################################

MAPOWANIE DO MODELI DTO

Je¿eli chcemy aby nasze API nie zwraca³o wszystkich danych z bazy, poniewa¿ na przyk³ad s¹ to poufne dane, to tworzymy Modele np RestaurantDto, w którym zawieramy tylko te informacje, które maj¹ trafiæ do klienta API.


Aby mapowaæ obiekty bazodanowe na modele Dto mo¿na u¿yæ AutoMappera. NuGet -> AutoMapper.Extensions.Microsoft.DependencyInjcetion
Nastêpnie tworzymy klasê do mapowania, która dzidziczy po klasie Profile:

    public class RestaurantMappingProfile: Profile
    {
        public RestaurantMappingProfile()
        {
            CreateMap<Restaurant, RestaurantDto>()
                .ForMember(m => m.City, c => c.MapFrom(s => s.Address.City))
                .ForMember(m => m.Country, c => c.MapFrom(s => s.Address.Country));

            CreateMap<Dish, DishDto>();
        }
    }

    **te pola z klas które s¹ identyczne w obu klasach s¹ mapowane automatycznie**

    Po utworzeniu klasy, dodajemy Mappera do kontrolera:

    private readonly IMapper mapper;

    public RestaurantController(RestaurantDbContext dbContext, IMapper mapper)
    {
        _context = dbContext;
        this.mapper = mapper;
    }

    Mapowanie w metodzie Get:

    [HttpGet]
    public ActionResult<IEnumerable<RestaurantDto>> GetAll()
    {
        var restaurants = _context.Restaurants.ToList();

        var restaurantsDto = mapper.Map<List<RestaurantDto>>(restaurants);


        return Ok(restaurantsDto);
    }

    Na koniec dodajemy service w klasie Startup:

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        services.AddDbContext<RestaurantDbContext>();
        services.AddScoped<RestaurantSeeder>();
        services.AddAutoMapper(this.GetType().Assembly);
    }

    Aby zawrzec tez inne klasy w naszych wynikach musimy uzyc w LINQ Include:

    var restaurant = _context
                .Restaurants
                .Include(r => r.Address)
                .Include(r => r.Dishes)
                .FirstOrDefault(x => x.Id == id);


########################################################################################################################################################################################################################################################

    Dodawanie elementu do bazy za pomoc¹ czasownika POST. Utworzenie encji za pomoc¹ modelu CreateDto.

    [HttpPost]
    public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
    {
        var restaurant = mapper.Map<Restaurant>(dto);
        _context.Restaurants.Add(restaurant);
        _context.SaveChanges();

        return Created($"/api/restaurant/{restaurant.Id}", null);
    }

    W ten sposób mo¿emy dodaæ metodê do wstawiania nowych danych do bazy.
    Zosta³a utworzona nowa klasa CreateRestaurantDto, której u¿ytkownik wpisuje obiekt w ciele zapytania.
    Zosta³o dodane nowe mapowanie w klasie MappingProfile, dziêki któremu odbywa siê mapowanie obiektu przekazanego przez u¿ytkownika, na obiekt który jest dodawany do bazy.
    Zwracamy tutaj odpowiedz typu Created oraz dajemy link do nowo utworzonej encji.


########################################################################################################################################################################################################################################################

    Walidacja

    Aby walidowaæ dane, które wprowadza u¿ytkownik poprzez zapytanie, najlepiej dodawaæ atrybuty w klasie do tworzenia obiektu przez uzytkownika API.
    [Required] - atrybut, który okreœla, ¿e to pole jest wymagane,
    [MaxLength()] - atrybut, który okreœla, ¿e to pole ma jak¹œ maksymaln¹ d³ugoœæ
    Inne atrybuty:
    [CreditCard] 
    [Compare("Inne pole klasy")]
    [EmailAdress]
    [Phone]
    [Range(minValue, maxValue)]
    [RegularExpression(pattern)]

    public class CreateRestaurantDto
    {
        [Required]
        [MaxLength(25)]
        public string Name { get; set; }
        public string Description { get; set; }
        public string Category { get; set; }
        public bool HasDelivery { get; set; }
        public bool ContactEmail { get; set; }
        public bool ContactPhone { get; set; }
        [Required]
        [MaxLength(50)]
        public string City { get; set; }
        public string Country { get; set; }
        [Required]
        [MaxLength(50)]
        public string Region { get; set; }
    }

    W ten sposób nastêpnie mo¿emy sprawdziæ czy wprowadzono poprawne dane i ewnetualnie wys³aæ BadRequest

    [HttpPost]
    public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
    {
        if(ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var restaurant = mapper.Map<Restaurant>(dto);
        _context.Restaurants.Add(restaurant);
        _context.SaveChanges();

        return Created($"/api/restaurant/{restaurant.Id}", null);
    }

########################################################################################################################################################################################################################################################

    Refaktor kontrolera

    Kontroler nie powininien zawieraæ du¿o logiki. Powinien on zawieraæ odebranie zapytania, ewentualn¹ walidacjê i przes³anie zapytania do jakiegoœ serwisu, który obs³uguje dane zapytanie. 
    Serwis wstrzykujemy poprzez Dependency Injection.

########################################################################################################################################################################################################################################################
    
    Usuwanie elementów

    Usuwanie elementów realizuje czasownik Delete

    //RestaurantController
    [HttpDelete("{id}")]
    public ActionResult Delete([FromRoute] int id)
    {
        var isDeleted = restaurantService.Delete(id);

        if(isDeleted)
        {
            return NoContent();
        }
        else
        {
            return NotFound();
        }
    }

    //RestaurantService
    public bool Delete(int id)
    {
        var restaurant = context
            .Restaurants
            .FirstOrDefault(x => x.Id == id);

        if (restaurant is null) return false;
        context.Restaurants .Remove(restaurant);
        context.SaveChanges();
        return true;
    }


########################################################################################################################################################################################################################################################

Loger

Aby mieæ pe³ny wgl¹d na to co dzia³o siê na serwerze, musimy dodaæ logowanie do aplikacji. Chodzi o zapis informacji w formie tekstowej np. do pliku tekstowego. 
Do naszego api dodamy biblioteke nlog.
nuget -> NLog.Web.AspNetCore

Trzeba dodaæ plik nlog.config, który konfiguruje logera.


Dodaktowo w klasie Program.cs dodajemy UseNLog:


        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                })
                .UseNLog();

Nastêpnie dodajemy logger do serwisu i wykonujemy jakiœ log w którejœ akcji.

    public class RestaurantService:IRestaurantService
    {
        private readonly RestaurantDbContext context;
        private readonly IMapper mapper;
        ***
        private readonly ILogger<RestaurantService> logger;

        public RestaurantService(RestaurantDbContext context, IMapper mapper, ILogger<RestaurantService> logger)
        {
            this.context = context;
            this.mapper = mapper;
            ***
            this.logger = logger;
        }

        public bool Delete(int id)
        {
        ***
            logger.LogWarning($"Restaurant with id: {id} DELETE action invoked");
            var restaurant = context
                .Restaurants
                .FirstOrDefault(x => x.Id == id);

            if (restaurant is null) return false;
            context.Restaurants.Remove(restaurant);
            context.SaveChanges();
            return true;
        }



########################################################################################################################################################################################################################################################

Error handling middleware

Aby z³apaæ b³¹d w aplikacji i w pe³ni wykorzystaæ logger dla wyj¹tków musimy ³apaæ wyj¹tki i w ramach ich obs³ugi zapisywaæ informacje poprzez logger. 
Zamiast dodawaæ try catch do wszystkich mo¿liwych miejsc, gdzie mo¿e wyst¹piæ wyj¹tek, mo¿emy stworzyæ w³asny middleware i dodaæ go do klasy stratup. 
Dziêki temu ka¿de zapytanie bêdzie procesowany przez ten middleware.

Tworzymy klasê Middleware, która implementuje interfejst IMiddleware.

    public class ErrorHandlingMiddleware : IMiddleware
    {
        public ILogger<ErrorHandlingMiddleware> logger;
        public ErrorHandlingMiddleware(ILogger<ErrorHandlingMiddleware> logger)
        {
            this.logger = logger;
        }

        public async Task InvokeAsync(HttpContext context, RequestDelegate next)
        {
            try
            {
                await next.Invoke(context);
            }
            catch(Exception e)
            {
                logger.LogError(e, e.Message);

                context.Response.StatusCode = 500;
                await context.Response.WriteAsync("Something went wrong...");
            }
        }
    }

    Klasa ta ma blok try catch, który próbuje wywo³aæ nastêpny middleware asynchronicznie. W obs³udze b³êdu logujemy b³¹d i wysy³amy odpowiedŸ do klienta z ustawieniem statusu na 500.

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        services.AddDbContext<RestaurantDbContext>();
        services.AddScoped<RestaurantSeeder>();
        services.AddScoped<IRestaurantService, RestaurantService>();
        services.AddAutoMapper(this.GetType().Assembly);
        services.AddScoped<ErrorHandlingMiddleware>();
    }

    W metodzie ConfigureServices w klasie Startup dodajemy nasz middleware.

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env, RestaurantSeeder seeder)
    {

        seeder.Seed();

        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseMiddleware<ErrorHandlingMiddleware>();

        app.UseHttpsRedirection();

        app.UseRouting();

        app.UseAuthorization();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }

    W metodzie Configure dodajemy nasz middleware na pocz¹tku przep³ywu zapytania.

########################################################################################################################################################################################################################################################

Customowe b³êdy API

W tym momencie ³apanie b³êdów API, np gdy dany zasób nie istnieje, by³o realizowane poprzez controller.
Controller wywo³uje metode z serwisu, która zwraca informacje o b³êdzie, a nastêpnie controller zwraca informacje do u¿ytkownika API.
Ta implementacja wprowadza zale¿noœæ pomiêdzy tymi dwoma klasami kontrolera i serwisu.
Aby pozbyæ siê tego powi¹zania, w serwisie mo¿na wyrzucaæ wyjatki oraz je przechwytywaæ w naszej klasie ErrorHandlingMiddleware.

**Nasze customowe wyj¹tki mo¿emy dodawaæ w folderze Exceptions. Wyjatek musi dziedziczyæ po klasie Exception oraz wywo³ywaæ konstruktor bazowy.

public class NotFoundException:Exception
{
    //base(message) - wywo³anie konstruktora bazowego
    public NotFoundException(string message) : base (message)
    {
            
    }
}

**Nastêpnie w klasie service wyrzucamy wyj¹tek:

public void Update(int id, UpdateRestaurantDto dto)
{
    var restaurant = context
        .Restaurants
        .FirstOrDefault(x => x.Id == id);
    if (restaurant is null) 
        throw new KeyNotFoundException("Restaurant not found");

    restaurant.Name = dto.Name;
    restaurant.Description = dto.Description;
    restaurant.HasDelivery = dto.HasDelivery;
    context.SaveChanges();
}

**Teraz nasza metoda w kontrolerze mo¿e byæ krótsza np:

[HttpPut("{id}")]
public ActionResult Update([FromRoute] int id, [FromBody] UpdateRestaurantDto dto)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }

    restaurantService.Update(id, dto);

    return Ok();
}

**Na koniec obs³ugujemy wyj¹tek w ErrorHandlingMiddleware

public async Task InvokeAsync(HttpContext context, RequestDelegate next)
{
    try
    {
        await next.Invoke(context);
    }
    catch(NotFoundException notFoundException)
    {
        context.Response.StatusCode = 404;
        await context.Response.WriteAsync(notFoundException.Message);
    }
    catch(Exception e)
    {
        logger.LogError(e, e.Message);

        context.Response.StatusCode = 500;
        await context.Response.WriteAsync("Something went wrong...");
    }
}

**Dodatkowo w naszym kontrolerze powtarza siê walidacja modelu w wielu metodach. Aby pozbyæ siê tych powtórzeñ dodajemy atrybut [ApiController]

namespace RestaurantAPI.Controllers
{
    [Route("api/restaurant")]
    [ApiController]
    public class RestaurantController : ControllerBase
    {
        private readonly IRestaurantService restaurantService;

        public RestaurantController(IRestaurantService restaurantService)
        {
            this.restaurantService = restaurantService;
        }

        ...

Dziêki temu kawa³ek kodu :

if (!ModelState.IsValid)
{
    return BadRequest(ModelState);
}

jest wywo³ywany automatycznie.



########################################################################################################################################################################################################################################################

Dokumentacja API - Swagger

Do naszego API przyda³aby siê dokumentacja dostêpnych akcji. Do tego mo¿e pos³u¿yæ Swagger. 
Je¿eli ktoœ inny ni¿ my mia³by stworzyæ frontend do naszego API, to musielibyœmy mu dostarczyæ informacje, jakie s¹ metody w naszym API oraz jak je wywo³aæ.
Swagger tworzy automatyczn¹ dokumentacje API na podstawie akcji w kontrolerach API.
Nuget -> Swashbuckle.AspNetCore

W klasie Startup w metodzie Configure Servies dodajemy:

services.AddSwaggerGen();

W metodzie configure:

...

app.UseHttpsRedirection();

app.UseSwagger();
app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "Restaurant API"));

...

Dziêki UseSwagger() zostanie wygenerowany plik json z dokumentacja
Dziêki UseSwaggerUI() zostanie wygenerowany interfejs u¿ytkownika, która bêdzie zawiera³ dokumentacje z wczeœniej stworzonego pliku json.

Aby dostaæ siê do interfejsu w przegl¹darce wpisujemy adres hosta ze œcie¿k¹ swagger np: https://localhost:44328/swagger.

Dziêki Swaggerowi ka¿dy kto chcia³by korzystaæ z naszego API mo¿e siê dowiedzieæ poprzez wygenrowany interfejs.

########################################################################################################################################################################################################################################################

Zarz¹dzanie podencjami

Je¿eli chcielibyœmy dodaæ kontroler do encji Dish to moglibyœmy to zrobiæ dodaj¹c adres api/dish. 
Natomiast problem z tym, jest taki, ¿e Dish nie mo¿e istnieæ bez restauracji, wiêc nie za bardzo mo¿na tak zrobiæ.
Aby to zrobiæ odpowiednio ustawiamy œcie¿kê api/restaurant/{restaurantId}/dish.


########################################################################################################################################################################################################################################################

AUTENTYKACJA

W tym momencie ka¿dy u¿ytkownik API mo¿e wykywaæ ka¿d¹ akcjê w bazie danych. Mog¹ oni usuwaæ zasoby nawet jeœli ich nie stworzyli.
Nie da³oby siê sprawdziæ jaki u¿ytkownik wys³a³ jakie zapytanie. 
Autentykacja to proces polegaj¹cy na potwierdzeniu to¿samoœci podmiotu bior¹cego udzia³ w komunikacji.
Ma za zadanie okreœliæ, czy u¿ytkownik jest tym, za kogo siê podaje. 

W przypadku autentykacjji elektronicznej stosuje siê:
**metody oparte no tokenach, 
**klucze prywatne
**has³a

Kategorie procesów autentykacji:
1. Coœ co masz (Token, telefon z oprogramowaniem, karta)
2. Coœ czym jesteœ (g³os, twarz, odcisk palca)
3. Coœ co wiesz (PIN, Has³o, pytanie pomocniczne)

W aplikacjach wra¿liwych czêsto stosuje siê autentykacje dwusk³adnikow¹. 

W tej aplikacji zostan¹ u¿yte has³a. 

Role:
*User - zwyk³y u¿ytkownik, który mo¿e tylko przegl¹daæ informacje o restauracjach 
*Menager - mo¿e zarz¹dzaæ swoimi restauracjami 
*Administrator - osoba, która mo¿e nadawaæ uprawnienia innym u¿ytkownikom

Aby dodaæ odpowiednie role i informacje musimy dodaæ odpowiednie tabele do bazy danych.

    public class User
    {
        public int Id { get; set; }
        public string Email { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime? DateOfBirth { get; set; }
        public string Nationality { get; set; }
        public string PasswordHash { get; set; }
        public int RoleId { get; set; }
        public virtual Role Role { get; set; }

    }

    public class Role
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

Role powinny mieæ zawsze ustalone wartoœci w bazie danych dlatego trzeba je zaseedowaæ.

########################################################################################################################################################################################################################################################

Hashowanie hase³.

Musimy byæ pewni, ¿e w przypadku w³amania do bazy danych, has³a u¿ytkowników nigdy nie zostan¹ ujawnione.
W ¿adnym wypadku nie chcemy przechowywaæ hase³ u¿ytkowników w postaci tekstu.
Wielu u¿ytkowników korzysta z tych samych hase³ na ró¿nych stronach. 
Przez to jest ryzyko, ¿e ich inne konta mog¹ byæ zaatakowane po ujawnienia hase³ w naszym API.

Hashowanie to powszechne podejscie do bezpiecznego zabezpieczenia hasla.
Hashowanie jest jednokierunkowe, czyli z wartosci po wykonaniu funkcji hashuj¹cej, nie uzyskamy ju¿ wartoœci pocz¹tkowej.

Gdy u¿ytkownik zarejestruje konto, jego has³o jest przechowywane jako hash w bazie danych.
Nastêpnie przy próbie zalogowania, wpisane has³o bêdzie ponownie zahashowane i porównane z tym, które jest ju¿ w bazie danych.
Jest wiele dostepnych paczek do wykonywania hashowania hase³.
W ASPNetCore.Identity istnieje klasa PasswordHasher, która s³u¿y do tego celu.
Klasa PasswordHasher zawiera dwie metody:
1.HasPassword do wykonania funkcji Hashuj¹cej dla danego u¿ytkownika.
2.VerifyHashedPassword, która dla u¿ytkownika, has³a z bazy i has³a wpisanego sprawdza, czy podano prawid³owe has³o.

Aby korzystaæ z klasy PasswordHasher trzeba j¹ zarejestrowaæ w kontrolerze zale¿noœci w klasie startup.

 services.AddScoped<IPasswordHasher<User>, PasswordHasher<User>>();

 U¿ycie hashera:

     public class AccountService: IAccountService
    {
        private readonly RestaurantDbContext context;
        private readonly IPasswordHasher<User> hasher;

        public AccountService(RestaurantDbContext context, IPasswordHasher<User> hasher)
        {
            this.context = context;
            this.hasher = hasher;
        }
        public void RegisterUser(RegisterUserDto dto)
        {
            var newUser = new User()
            {
                Email = dto.Email,
                DateOfBirth = dto.DateOfBirth,
                Nationality = dto.Nationality,
                RoleId = dto.RoleId
            };
            var hashedPassword = hasher.HashPassword(newUser, dto.Password);

            newUser.PasswordHash = hashedPassword;

            context.Users.Add(newUser); 
            context.SaveChanges();
        }
    }


########################################################################################################################################################################################################################################################

Walidacja

W tym momencie za pomoc¹ poprzedniej metody, czyli dodawania atrybutów na pola w modelu mo¿liwa by³¹ realizacja walidacji.
Niestety, je¿eli chcemy dodaæ walidacjê, która sprawdza³aby, czy istnieje ju¿ w bazie taki login uzytkownika, nie mozemy w ten sposob tego zrobic.
Do realizacji walidacji mozna korzystac z paczki FluentValidation, która pozwala na nakladanie zasad walidacji na konkretny model w bardzo elastyczny sposob.

Tak wygl¹da dodana klasa, która okreœla zasady walidacji dla modelu RegisterUserDto za pomoc¹ FluentValidation:

namespace RestaurantAPI.Models.Validators
{
    public class RegisterUserDtoValidator: AbstractValidator<RegisterUserDto>
    {
        public RegisterUserDtoValidator(RestaurantDbContext dbContext)
        {
            RuleFor(x => x.Email)
                .NotEmpty()
                .EmailAddress();

            RuleFor(x => x.Password)
                .MinimumLength(6);

            RuleFor(x => x.ConfirmPassword).Equal(e => e.Password);

            RuleFor(x => x.Email)
                .Custom((value, context) =>
                {
                    var emailInUse = dbContext.Users.Any(u => u.Email == value);
                    if(emailInUse)
                    {
                        context.AddFailure("Email", "That email is taken");
                    }
                });
        }
    }
}

W metodzie configureservices w klasie startup trzeba ta klasie zarejestrowaæ w kontenerze zale¿noœci. 

services.AddControllers().AddFluentValidation();
services.AddScoped<IValidator<RegisterUserDto>, RegisterUserDtoValidator>();

########################################################################################################################################################################################################################################################

Autentykacja za pomoc¹ Json Web Token (JWT)

JWT to standard internetowy do tworzenia tokenow dostepow opartych na formacie json.
Token zawiera informacje o pewnych stwierdzeniach o jego posiadaczu nazwanych claimami.
Takie stwierdzenie to na przyklad informacja, ¿e uzytkownik jest w roli admina.
Tokeny s¹ generowane po stronie serwera przy uzyciu klucza prywatnego lub przy uzyciu kombinacji klucza prywantego i publicznego.
Klient mo¿e u¿yc tokena aby udowodniæ, ¿e jest zalogowany jako administrator.
Serwer generuj¹c taki token podpisuje go kluczem prywatnym, przez co póŸniej mo¿e zweryfikowaæ czy dany token wyslany od klienta jest zgodny z kluczem, który posiada serwer.
Serwer robi to po to aby wykluczyæ próbe autentykacji nieprawid³owym tokenem.

Typowa autentykacja przy logowaniu wygl¹da nastêpuj¹co:

Uzytkownik wysy³a zapytanie z akcj¹ typu POST, gdzie podaje swój email i has³o. 
Aplikacja, czy te¿ serwer, sprawdza poprawnoœæ has³a za pomoc¹ hashu oraz czy taki u¿ytkownik istnieje w bazie.
Jeœli dane s¹ poprawne, serwer generuje Token zawieraj¹cy claimy i wysy³a go u¿ytkownikowi. 
Klient po otrzymaniu tokena JWT jest w stanie autentykowaæ siê przy wysy³aniu nastêpnych zapytañ poprzez umieszczenie tokena JWT w nag³ówku autoryzacji.
Serwer sprawdza, czy dany token nie wygas³ oraz czy klucz prywatny zgadza siê z wartoœci¹ tokena.

Ka¿dy token JWT jest podzielony na 3 czeœæi.
1. Nag³ówek - zawiera informacje jaki algorytm zosta³ u¿yty do wygenerowania podpisu
2. Payload - zbiór claimów, które zawieraj¹ informacje o posiadaczu tokena
3. Podpis - s³u¿y do sprawdzenia poprawnoœci tokena

Jak dodaæ Jwt do aplikacji. W pliku appsettings.json dodajemy:

  "Authentication": {
    "JwtKey": "PRIVATE_KEY_DONT_SHARE",
    "JwtExpireDays": 15,
    "JwtIssuer": "http://restaurantapi.com"
  },

Nastêpnie tworzymy klasê, która bêdzie reprezentowaæ te ustawienia:

    public class AuthenticationSettings
    {
        public string JwtKet { get; set; }
        public int JwtExpireDays { get; set; }
        public string JwtIssuer { get; set; }
    }


W klasie startup musimy skonfigurowaæ te ustawienia.

W metodzie Configure:

    app.UseAuthentication();

W metodzie ConfigureServices:

    var authenticationSettings = new AuthenticationSettings();

    Configuration.GetSection("Authentication").Bind(authenticationSettings); // wten sposob mozna dostac sie do ustawien z pliku appsettings.json

    services.AddAuthentication(option =>
    {
        option.DefaultAuthenticateScheme = "Bearer";
        option.DefaultScheme = "Bearer";
        option.DefaultChallengeScheme = "Bearer";
    }).AddJwtBearer(cfg =>
    {
        cfg.RequireHttpsMetadata = false;
        cfg.SaveToken = true;
        cfg.TokenValidationParameters = new TokenValidationParameters
        {
            ValidIssuer = authenticationSettings.JwtIssuer,
            ValidAudience = authenticationSettings.JwtIssuer,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(authenticationSettings.JwtKey)),
        };
    });

Metoda w AccountService do wygenerowania tokenu: 

public string GenerateJwt(LoginDto dto)
{
    var user = context.Users
        .Include(u=>u.Role)
        .FirstOrDefault(u => u.Email == dto.Email);
    if(user == null)
    {
        throw new BadRequestException("Invalid username or password");
    }
    var result = hasher.VerifyHashedPassword(user, user.PasswordHash, dto.Password);
    if(result == PasswordVerificationResult.Failed)
    {
        throw new BadRequestException("Invalid username or password");
    }

    var claimes = new List<Claim>()
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
        new Claim(ClaimTypes.Name, $"{user.FirstName} {user.LastName}"),
        new Claim(ClaimTypes.Role, user.Role.Name),
        new Claim("DateOfBirth", user.DateOfBirth.Value.ToString("yyyy-MM-dd")),
        new Claim("Nationality", user.Nationality)
    };

    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(authenticationSettings.JwtKey));
    var cred = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
    var expires = DateTime.Now.AddDays(authenticationSettings.JwtExpireDays);

    var token = new JwtSecurityToken(authenticationSettings.JwtIssuer,
        authenticationSettings.JwtIssuer,
        claimes,
        expires: expires,
        signingCredentials: cred);

    var tokenHandler = new JwtSecurityTokenHandler();
    return tokenHandler.WriteToken(token);

}

I w klasie kontrolera:

[HttpPost("login")]
public ActionResult Login([FromBody] LoginDto dto)
{
    string token = service.GenerateJwt(dto);
    return Ok(token);   
}

Je¿eli u¿ytkownik wprowadzi swój token w nag³ówku zapytania, to w kontrolerze mo¿emy uzyskiwaæ informacje o u¿ytkowniku z claimów wiêc w ten sposób wiemy, kto wysy³a zapytanie na serwer.
Dziêki temu, ¿e mo¿emy zidentyfikowaæ u¿ytkownika, mo¿emy równie¿ zautoryzowaæ u¿ytkownika do wykonania jakiejœ akcji na serwerze. 


########################################################################################################################################################################################################################################################

AUTORYZACJA

Autoryzacja jest to sprawdzenie, czy dany u¿ytkownik ma dostêp do wykonania jakiejœ akcji czy nie.

W ASP.NET Core wyró¿niamy trzy podstawowe typy autoryzacji:
-Prosta autoryzacja na podstawie roli uzytkownika
-Autoryzacja na podstawie informacji w claimie zawartym w tokenie Jwt
-Customowa polityka zdefiniowana w dowolny przez nas sposób

Aby dodaæ autoryzacje trzeba w klasie startup w metodzie configure dodaæ wywolanie metody app.UseAutorization.
Metode t¹ trzeba wywo³awaæ pomiêdzy app.UseRouting oraz app.UseEndpoints
Czyli najpierw musimy zmapowaæ akcje w kontrolerze, pozniej zautoryzowac uzytkownika i jezeli autoryzacja przebiegnie poprawnie, to wykonaæ dan¹ akcjê.
Oprócz tego musimy dodaæ autoryzacjê na poziomie konkretnej akcji lub kontrolera.


[HttpGet]
[Authorize]
public ActionResult<IEnumerable<RestaurantDto>> GetAll()
{
    var restaurantsDto = restaurantService.GetAll();

    return Ok(restaurantsDto);
}
Je¿eli chcemy aby pobranie listy wszystkich restauracji bylo mozliwe tylko dla zalogowanych uzytkownikow.
Dziêki dodaniu atrybutu [Authorize] aplikacja sprawdzi automatycznie, czy naglowek zapytania zawiera odpowiedni token. 

Teraz przy zapytaniu uzytkownik musi podac token w naglowku zapytania.

Ten sam atrybut mo¿emy na³o¿yæ na poziomie ca³ego kontrolera.

Je¿eli majac atrybut na poziomie calego kontrolera chcemy aby jakas akcja nie miala autoryzacji, to mozemy dodac do niej atrybut [AllowAnonymous]


########################################################################################################################################################################################################################################################

AUTORYZACJA ROL¥ UZYTKOWNIKA

Do autoryzowania rol¹ u¿ytkownika mo¿emy u¿yc atrybut [Authorize] z konstruktorem, który zawiera property o nazwie Role np:

[HttpPost]
[Authorize(Roles = "Admin, Menager")]
public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
{
    int id = restaurantService.Create(dto);

    return Created($"/api/restaurant/{id}", null);
}

Teraz do tej akcji maj¹ dostêp u¿ytkownicy, którzy maj¹ rolê Admin lub Manager. Aby to zadzia³o token musi zawieraæ claim z rol¹ u¿ytkownika. 

var claimes = new List<Claim>()
{
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
    new Claim(ClaimTypes.Name, $"{user.FirstName} {user.LastName}"),
    new Claim(ClaimTypes.Role, user.Role.Name),
    new Claim("DateOfBirth", user.DateOfBirth.Value.ToString("yyyy-MM-dd")),
    new Claim("Nationality", user.Nationality)
};

########################################################################################################################################################################################################################################################

AUTORYZACJA WARTOSCIA CLAIMU

services.AddAuthorization(options =>
{
    options.AddPolicy("HasNationality", builder => builder.RequireClaim("Nationality"))
});

W ten sposób w klasie startup mo¿emy dodaæ w³asn¹ polityke, która sprawdza, czy Claim Nationality istnieje w tokenie. 
Aby u¿yc tej polityki w RestaurantController:

[HttpGet]
[Authorize(Policy = "HasNationality")]
public ActionResult<IEnumerable<RestaurantDto>> GetAll()
{
    var restaurantsDto = restaurantService.GetAll();

    return Ok(restaurantsDto);
}

Teraz akcja Get bêdzie wymaga³a, aby uzytkownik mial narodowosc w tokenie. 

Aby dodaæ do naszej polityki, ¿e dany claim musi zawieraæ konkretn¹ wartoœæ, mo¿na to zrobiæ w ten sposób:

services.AddAuthorization(options =>
{
    options.AddPolicy("HasNationality", builder => builder.RequireClaim("Nationality", "Poland", "German"));
});




########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################