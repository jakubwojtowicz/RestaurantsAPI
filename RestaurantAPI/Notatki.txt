########################################################################################################################################################################################################################################################
Utworzenie migracji i zaktualizowanie bazy danych:

add-migration <Nazwa>

update-database



########################################################################################################################################################################################################################################################

Dependency Injection:

* Dodanie zale¿noœci Dependency Injection
* AddSingleton - mamy pewnoœæ, ¿e dana zale¿noœæ zosta³a utworzona tylko raz podczas trwania aplikacji.
* AddScoped - na jedno zapytanie bêdziemy mieæ jedn¹ instancje danego serwisu            
* AddTransient - obiekty bêd¹ tworzone za ka¿dym razem, kiedy odwo³ujemy siê do nich przez konstruktor.

services.AddScoped<IWeatherForecastService, WeatherForecastService>();

Dodajemy te zale¿noœci w metodzie ConfigureServices.

########################################################################################################################################################################################################################################################

ATRYBUTY

[Route("api/restaurant")]

To jest atrybut kontrolera, który s³u¿y do tego aby mo¿liwe by³o po³¹czenie zapytania z odpowiedni¹ akcj¹.
Dziêki temu, ¿e dodaliœmy api/restaruant, mo¿emy dodawaæ te¿ inne kontrolery, a nie tylko restaurant.

 * Dziêki atrybutowi Route mo¿emy dodaæ kolejny Get do naszego kontrolera. Bez tego by³by wyj¹tek, poniewa¿
 * program musi wiedzieæ do czego ma siê odnieœæ przy zapytaniu. 
        [HttpGet]
        [Route("currentDay")] ->  /weatherforecast/currentDay


 * Inna metod¹ zmiany œcie¿ki akcji jest dodanie argumentu do atrybutu HttpGet: [HttpGet("currentDay")]

########################################################################################################################################################################################################################################################

MAPOWANIE ARGUMENTOW ZAPYTAN

 * Mapowanie atrybutów, przesy³anie parametrów do akcji.
 * Dla parametró w nawiasach w metodach musimy sprecyzowaæ, sk¹d dany parametr pochodzi.
 * Parametr mo¿e pochodziæ z adresu zapytania lub z cia³a zapytania.
 * FromRoute - przekazanie poprzez œcie¿ke -> [Route("currentDay/{max}")]
 * FromQuery - przekazanie poprzez zapytanie
 * FromBody - poprzez cia³o zapytania na przyk³ad: ([FromBody] string name)
 * Parametry trzeba odpowiednio zmapowaæ, tak aby program wiedzia³ jak po³¹czyæ zapytanie z odpowiedni¹ akcj¹
 
 Sposoby zwracania statusów zapytania
 Http context to w³asnoœæ kontrolera, dziêki której mamy dostêp do zapytania jak i odpoweidzi Http


 Aby metoda zwraca³a kod musi mieæ typ taki typ zwracanej wartoœci:

    public ActionResult<string> Hello2([FromBody] string name)
    {
            HttpContext.Response.StatusCode = 401; -> pierwszy sposób 
            return $"Hello {name}"; 
            return StatusCode(401, $"Hello {name}"); -> drugi sposób Status Code
            return NotFound($"Hello {name}"); ->trzeci sposób poprzez zwrocenie metody
    }

########################################################################################################################################################################################################################################################

MAPOWANIE DO MODELI DTO

Je¿eli chcemy aby nasze API nie zwraca³o wszystkich danych z bazy, poniewa¿ na przyk³ad s¹ to poufne dane, to tworzymy Modele np RestaurantDto, w którym zawieramy tylko te informacje, które maj¹ trafiæ do klienta API.


Aby mapowaæ obiekty bazodanowe na modele Dto mo¿na u¿yæ AutoMappera. NuGet -> AutoMapper.Extensions.Microsoft.DependencyInjcetion
Nastêpnie tworzymy klasê do mapowania, która dzidziczy po klasie Profile:

    public class RestaurantMappingProfile: Profile
    {
        public RestaurantMappingProfile()
        {
            CreateMap<Restaurant, RestaurantDto>()
                .ForMember(m => m.City, c => c.MapFrom(s => s.Address.City))
                .ForMember(m => m.Country, c => c.MapFrom(s => s.Address.Country));

            CreateMap<Dish, DishDto>();
        }
    }

    **te pola z klas które s¹ identyczne w obu klasach s¹ mapowane automatycznie**

    Po utworzeniu klasy, dodajemy Mappera do kontrolera:

    private readonly IMapper mapper;

    public RestaurantController(RestaurantDbContext dbContext, IMapper mapper)
    {
        _context = dbContext;
        this.mapper = mapper;
    }

    Mapowanie w metodzie Get:

    [HttpGet]
    public ActionResult<IEnumerable<RestaurantDto>> GetAll()
    {
        var restaurants = _context.Restaurants.ToList();

        var restaurantsDto = mapper.Map<List<RestaurantDto>>(restaurants);


        return Ok(restaurantsDto);
    }

    Na koniec dodajemy service w klasie Startup:

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        services.AddDbContext<RestaurantDbContext>();
        services.AddScoped<RestaurantSeeder>();
        services.AddAutoMapper(this.GetType().Assembly);
    }

    Aby zawrzec tez inne klasy w naszych wynikach musimy uzyc w LINQ Include:

    var restaurant = _context
                .Restaurants
                .Include(r => r.Address)
                .Include(r => r.Dishes)
                .FirstOrDefault(x => x.Id == id);


########################################################################################################################################################################################################################################################

    Dodawanie elementu do bazy za pomoc¹ czasownika POST. Utworzenie encji za pomoc¹ modelu CreateDto.

    [HttpPost]
    public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
    {
        var restaurant = mapper.Map<Restaurant>(dto);
        _context.Restaurants.Add(restaurant);
        _context.SaveChanges();

        return Created($"/api/restaurant/{restaurant.Id}", null);
    }

    W ten sposób mo¿emy dodaæ metodê do wstawiania nowych danych do bazy.
    Zosta³a utworzona nowa klasa CreateRestaurantDto, której u¿ytkownik wpisuje obiekt w ciele zapytania.
    Zosta³o dodane nowe mapowanie w klasie MappingProfile, dziêki któremu odbywa siê mapowanie obiektu przekazanego przez u¿ytkownika, na obiekt który jest dodawany do bazy.
    Zwracamy tutaj odpowiedz typu Created oraz dajemy link do nowo utworzonej encji.


########################################################################################################################################################################################################################################################

    Walidacja

    Aby walidowaæ dane, które wprowadza u¿ytkownik poprzez zapytanie, najlepiej dodawaæ atrybuty w klasie do tworzenia obiektu przez uzytkownika API.
    [Required] - atrybut, który okreœla, ¿e to pole jest wymagane,
    [MaxLength()] - atrybut, który okreœla, ¿e to pole ma jak¹œ maksymaln¹ d³ugoœæ
    Inne atrybuty:
    [CreditCard] 
    [Compare("Inne pole klasy")]
    [EmailAdress]
    [Phone]
    [Range(minValue, maxValue)]
    [RegularExpression(pattern)]

    public class CreateRestaurantDto
    {
        [Required]
        [MaxLength(25)]
        public string Name { get; set; }
        public string Description { get; set; }
        public string Category { get; set; }
        public bool HasDelivery { get; set; }
        public bool ContactEmail { get; set; }
        public bool ContactPhone { get; set; }
        [Required]
        [MaxLength(50)]
        public string City { get; set; }
        public string Country { get; set; }
        [Required]
        [MaxLength(50)]
        public string Region { get; set; }
    }

    W ten sposób nastêpnie mo¿emy sprawdziæ czy wprowadzono poprawne dane i ewnetualnie wys³aæ BadRequest

    [HttpPost]
    public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
    {
        if(ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var restaurant = mapper.Map<Restaurant>(dto);
        _context.Restaurants.Add(restaurant);
        _context.SaveChanges();

        return Created($"/api/restaurant/{restaurant.Id}", null);
    }

########################################################################################################################################################################################################################################################

    Refaktor kontrolera

    Kontroler nie powininien zawieraæ du¿o logiki. Powinien on zawieraæ odebranie zapytania, ewentualn¹ walidacjê i przes³anie zapytania do jakiegoœ serwisu, który obs³uguje dane zapytanie. 
    Serwis wstrzykujemy poprzez Dependency Injection.

########################################################################################################################################################################################################################################################
    
    Usuwanie elementów

    Usuwanie elementów realizuje czasownik Delete

    //RestaurantController
    [HttpDelete("{id}")]
    public ActionResult Delete([FromRoute] int id)
    {
        var isDeleted = restaurantService.Delete(id);

        if(isDeleted)
        {
            return NoContent();
        }
        else
        {
            return NotFound();
        }
    }

    //RestaurantService
    public bool Delete(int id)
    {
        var restaurant = context
            .Restaurants
            .FirstOrDefault(x => x.Id == id);

        if (restaurant is null) return false;
        context.Restaurants .Remove(restaurant);
        context.SaveChanges();
        return true;
    }


########################################################################################################################################################################################################################################################

Loger

Aby mieæ pe³ny wgl¹d na to co dzia³o siê na serwerze, musimy dodaæ logowanie do aplikacji. Chodzi o zapis informacji w formie tekstowej np. do pliku tekstowego. 
Do naszego api dodamy biblioteke nlog.
nuget -> NLog.Web.AspNetCore

Trzeba dodaæ plik nlog.config, który konfiguruje logera.


Dodaktowo w klasie Program.cs dodajemy UseNLog:


        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                })
                .UseNLog();

Nastêpnie dodajemy logger do serwisu i wykonujemy jakiœ log w którejœ akcji.

    public class RestaurantService:IRestaurantService
    {
        private readonly RestaurantDbContext context;
        private readonly IMapper mapper;
        ***
        private readonly ILogger<RestaurantService> logger;

        public RestaurantService(RestaurantDbContext context, IMapper mapper, ILogger<RestaurantService> logger)
        {
            this.context = context;
            this.mapper = mapper;
            ***
            this.logger = logger;
        }

        public bool Delete(int id)
        {
        ***
            logger.LogWarning($"Restaurant with id: {id} DELETE action invoked");
            var restaurant = context
                .Restaurants
                .FirstOrDefault(x => x.Id == id);

            if (restaurant is null) return false;
            context.Restaurants.Remove(restaurant);
            context.SaveChanges();
            return true;
        }



########################################################################################################################################################################################################################################################

Error handling middleware

Aby z³apaæ b³¹d w aplikacji i w pe³ni wykorzystaæ logger dla wyj¹tków musimy ³apaæ wyj¹tki i w ramach ich obs³ugi zapisywaæ informacje poprzez logger. 
Zamiast dodawaæ try catch do wszystkich mo¿liwych miejsc, gdzie mo¿e wyst¹piæ wyj¹tek, mo¿emy stworzyæ w³asny middleware i dodaæ go do klasy stratup. 
Dziêki temu ka¿de zapytanie bêdzie procesowany przez ten middleware.

Tworzymy klasê Middleware, która implementuje interfejst IMiddleware.

    public class ErrorHandlingMiddleware : IMiddleware
    {
        public ILogger<ErrorHandlingMiddleware> logger;
        public ErrorHandlingMiddleware(ILogger<ErrorHandlingMiddleware> logger)
        {
            this.logger = logger;
        }

        public async Task InvokeAsync(HttpContext context, RequestDelegate next)
        {
            try
            {
                await next.Invoke(context);
            }
            catch(Exception e)
            {
                logger.LogError(e, e.Message);

                context.Response.StatusCode = 500;
                await context.Response.WriteAsync("Something went wrong...");
            }
        }
    }

    Klasa ta ma blok try catch, który próbuje wywo³aæ nastêpny middleware asynchronicznie. W obs³udze b³êdu logujemy b³¹d i wysy³amy odpowiedŸ do klienta z ustawieniem statusu na 500.

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        services.AddDbContext<RestaurantDbContext>();
        services.AddScoped<RestaurantSeeder>();
        services.AddScoped<IRestaurantService, RestaurantService>();
        services.AddAutoMapper(this.GetType().Assembly);
        services.AddScoped<ErrorHandlingMiddleware>();
    }

    W metodzie ConfigureServices w klasie Startup dodajemy nasz middleware.

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env, RestaurantSeeder seeder)
    {

        seeder.Seed();

        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseMiddleware<ErrorHandlingMiddleware>();

        app.UseHttpsRedirection();

        app.UseRouting();

        app.UseAuthorization();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }

    W metodzie Configure dodajemy nasz middleware na pocz¹tku przep³ywu zapytania.

########################################################################################################################################################################################################################################################

Customowe b³êdy API

W tym momencie ³apanie b³êdów API, np gdy dany zasób nie istnieje, by³o realizowane poprzez controller.
Controller wywo³uje metode z serwisu, która zwraca informacje o b³êdzie, a nastêpnie controller zwraca informacje do u¿ytkownika API.
Ta implementacja wprowadza zale¿noœæ pomiêdzy tymi dwoma klasami kontrolera i serwisu.
Aby pozbyæ siê tego powi¹zania, w serwisie mo¿na wyrzucaæ wyjatki oraz je przechwytywaæ w naszej klasie ErrorHandlingMiddleware.

**Nasze customowe wyj¹tki mo¿emy dodawaæ w folderze Exceptions. Wyjatek musi dziedziczyæ po klasie Exception oraz wywo³ywaæ konstruktor bazowy.

public class NotFoundException:Exception
{
    //base(message) - wywo³anie konstruktora bazowego
    public NotFoundException(string message) : base (message)
    {
            
    }
}

**Nastêpnie w klasie service wyrzucamy wyj¹tek:

public void Update(int id, UpdateRestaurantDto dto)
{
    var restaurant = context
        .Restaurants
        .FirstOrDefault(x => x.Id == id);
    if (restaurant is null) 
        throw new KeyNotFoundException("Restaurant not found");

    restaurant.Name = dto.Name;
    restaurant.Description = dto.Description;
    restaurant.HasDelivery = dto.HasDelivery;
    context.SaveChanges();
}

**Teraz nasza metoda w kontrolerze mo¿e byæ krótsza np:

[HttpPut("{id}")]
public ActionResult Update([FromRoute] int id, [FromBody] UpdateRestaurantDto dto)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }

    restaurantService.Update(id, dto);

    return Ok();
}

**Na koniec obs³ugujemy wyj¹tek w ErrorHandlingMiddleware

public async Task InvokeAsync(HttpContext context, RequestDelegate next)
{
    try
    {
        await next.Invoke(context);
    }
    catch(NotFoundException notFoundException)
    {
        context.Response.StatusCode = 404;
        await context.Response.WriteAsync(notFoundException.Message);
    }
    catch(Exception e)
    {
        logger.LogError(e, e.Message);

        context.Response.StatusCode = 500;
        await context.Response.WriteAsync("Something went wrong...");
    }
}

**Dodatkowo w naszym kontrolerze powtarza siê walidacja modelu w wielu metodach. Aby pozbyæ siê tych powtórzeñ dodajemy atrybut [ApiController]

namespace RestaurantAPI.Controllers
{
    [Route("api/restaurant")]
    [ApiController]
    public class RestaurantController : ControllerBase
    {
        private readonly IRestaurantService restaurantService;

        public RestaurantController(IRestaurantService restaurantService)
        {
            this.restaurantService = restaurantService;
        }

        ...

Dziêki temu kawa³ek kodu :

if (!ModelState.IsValid)
{
    return BadRequest(ModelState);
}

jest wywo³ywany automatycznie.



########################################################################################################################################################################################################################################################

Dokumentacja API - Swagger

Do naszego API przyda³aby siê dokumentacja dostêpnych akcji. Do tego mo¿e pos³u¿yæ Swagger. 
Je¿eli ktoœ inny ni¿ my mia³by stworzyæ frontend do naszego API, to musielibyœmy mu dostarczyæ informacje, jakie s¹ metody w naszym API oraz jak je wywo³aæ.
Swagger tworzy automatyczn¹ dokumentacje API na podstawie akcji w kontrolerach API.
Nuget -> Swashbuckle.AspNetCore

W klasie Startup w metodzie Configure Servies dodajemy:

services.AddSwaggerGen();

W metodzie configure:

...

app.UseHttpsRedirection();

app.UseSwagger();
app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "Restaurant API"));

...

Dziêki UseSwagger() zostanie wygenerowany plik json z dokumentacja
Dziêki UseSwaggerUI() zostanie wygenerowany interfejs u¿ytkownika, która bêdzie zawiera³ dokumentacje z wczeœniej stworzonego pliku json.

Aby dostaæ siê do interfejsu w przegl¹darce wpisujemy adres hosta ze œcie¿k¹ swagger np: https://localhost:44328/swagger.

Dziêki Swaggerowi ka¿dy kto chcia³by korzystaæ z naszego API mo¿e siê dowiedzieæ poprzez wygenrowany interfejs.

########################################################################################################################################################################################################################################################

Zarz¹dzanie podencjami

Je¿eli chcielibyœmy dodaæ kontroler do encji Dish to moglibyœmy to zrobiæ dodaj¹c adres api/dish. 
Natomiast problem z tym, jest taki, ¿e Dish nie mo¿e istnieæ bez restauracji, wiêc nie za bardzo mo¿na tak zrobiæ.
Aby to zrobiæ odpowiednio ustawiamy œcie¿kê api/restaurant/{restaurantId}/dish.


########################################################################################################################################################################################################################################################

AUTENTYKACJA

W tym momencie ka¿dy u¿ytkownik API mo¿e wykywaæ ka¿d¹ akcjê w bazie danych. Mog¹ oni usuwaæ zasoby nawet jeœli ich nie stworzyli.
Nie da³oby siê sprawdziæ jaki u¿ytkownik wys³a³ jakie zapytanie. 
Autentykacja to proces polegaj¹cy na potwierdzeniu to¿samoœci podmiotu bior¹cego udzia³ w komunikacji.
Ma za zadanie okreœliæ, czy u¿ytkownik jest tym, za kogo siê podaje. 

W przypadku autentykacjji elektronicznej stosuje siê:
**metody oparte no tokenach, 
**klucze prywatne
**has³a

Kategorie procesów autentykacji:
1. Coœ co masz (Token, telefon z oprogramowaniem, karta)
2. Coœ czym jesteœ (g³os, twarz, odcisk palca)
3. Coœ co wiesz (PIN, Has³o, pytanie pomocniczne)

W aplikacjach wra¿liwych czêsto stosuje siê autentykacje dwusk³adnikow¹. 

W tej aplikacji zostan¹ u¿yte has³a. 

Role:
*User - zwyk³y u¿ytkownik, który mo¿e tylko przegl¹daæ informacje o restauracjach 
*Menager - mo¿e zarz¹dzaæ swoimi restauracjami 
*Administrator - osoba, która mo¿e nadawaæ uprawnienia innym u¿ytkownikom

Aby dodaæ odpowiednie role i informacje musimy dodaæ odpowiednie tabele do bazy danych.

    public class User
    {
        public int Id { get; set; }
        public string Email { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime? DateOfBirth { get; set; }
        public string Nationality { get; set; }
        public string PasswordHash { get; set; }
        public int RoleId { get; set; }
        public virtual Role Role { get; set; }

    }

    public class Role
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

Role powinny mieæ zawsze ustalone wartoœci w bazie danych dlatego trzeba je zaseedowaæ.

########################################################################################################################################################################################################################################################

Hashowanie hase³.

Musimy byæ pewni, ¿e w przypadku w³amania do bazy danych, has³a u¿ytkowników nigdy nie zostan¹ ujawnione.
W ¿adnym wypadku nie chcemy przechowywaæ hase³ u¿ytkowników w postaci tekstu.
Wielu u¿ytkowników korzysta z tych samych hase³ na ró¿nych stronach. 
Przez to jest ryzyko, ¿e ich inne konta mog¹ byæ zaatakowane po ujawnienia hase³ w naszym API.

Hashowanie to powszechne podejscie do bezpiecznego zabezpieczenia hasla.
Hashowanie jest jednokierunkowe, czyli z wartosci po wykonaniu funkcji hashuj¹cej, nie uzyskamy ju¿ wartoœci pocz¹tkowej.

Gdy u¿ytkownik zarejestruje konto, jego has³o jest przechowywane jako hash w bazie danych.
Nastêpnie przy próbie zalogowania, wpisane has³o bêdzie ponownie zahashowane i porównane z tym, które jest ju¿ w bazie danych.
Jest wiele dostepnych paczek do wykonywania hashowania hase³.
W ASPNetCore.Identity istnieje klasa PasswordHasher, która s³u¿y do tego celu.
Klasa PasswordHasher zawiera dwie metody:
1.HasPassword do wykonania funkcji Hashuj¹cej dla danego u¿ytkownika.
2.VerifyHashedPassword, która dla u¿ytkownika, has³a z bazy i has³a wpisanego sprawdza, czy podano prawid³owe has³o.

Aby korzystaæ z klasy PasswordHasher trzeba j¹ zarejestrowaæ w kontrolerze zale¿noœci w klasie startup.

 services.AddScoped<IPasswordHasher<User>, PasswordHasher<User>>();

 U¿ycie hashera:

     public class AccountService: IAccountService
    {
        private readonly RestaurantDbContext context;
        private readonly IPasswordHasher<User> hasher;

        public AccountService(RestaurantDbContext context, IPasswordHasher<User> hasher)
        {
            this.context = context;
            this.hasher = hasher;
        }
        public void RegisterUser(RegisterUserDto dto)
        {
            var newUser = new User()
            {
                Email = dto.Email,
                DateOfBirth = dto.DateOfBirth,
                Nationality = dto.Nationality,
                RoleId = dto.RoleId
            };
            var hashedPassword = hasher.HashPassword(newUser, dto.Password);

            newUser.PasswordHash = hashedPassword;

            context.Users.Add(newUser); 
            context.SaveChanges();
        }
    }


########################################################################################################################################################################################################################################################

Walidacja

W tym momencie za pomoc¹ poprzedniej metody, czyli dodawania atrybutów na pola w modelu mo¿liwa by³¹ realizacja walidacji.
Niestety, je¿eli chcemy dodaæ walidacjê, która sprawdza³aby, czy istnieje ju¿ w bazie taki login uzytkownika, nie mozemy w ten sposob tego zrobic.
Do realizacji walidacji mozna korzystac z paczki FluentValidation, która pozwala na nakladanie zasad walidacji na konkretny model w bardzo elastyczny sposob.

Tak wygl¹da dodana klasa, która okreœla zasady walidacji dla modelu RegisterUserDto za pomoc¹ FluentValidation:

namespace RestaurantAPI.Models.Validators
{
    public class RegisterUserDtoValidator: AbstractValidator<RegisterUserDto>
    {
        public RegisterUserDtoValidator(RestaurantDbContext dbContext)
        {
            RuleFor(x => x.Email)
                .NotEmpty()
                .EmailAddress();

            RuleFor(x => x.Password)
                .MinimumLength(6);

            RuleFor(x => x.ConfirmPassword).Equal(e => e.Password);

            RuleFor(x => x.Email)
                .Custom((value, context) =>
                {
                    var emailInUse = dbContext.Users.Any(u => u.Email == value);
                    if(emailInUse)
                    {
                        context.AddFailure("Email", "That email is taken");
                    }
                });
        }
    }
}

W metodzie configureservices w klasie startup trzeba ta klasie zarejestrowaæ w kontenerze zale¿noœci. 

services.AddControllers().AddFluentValidation();
services.AddScoped<IValidator<RegisterUserDto>, RegisterUserDtoValidator>();

########################################################################################################################################################################################################################################################

Autentykacja za pomoc¹ Json Web Token (JWT)

JWT to standard internetowy do tworzenia tokenow dostepow opartych na formacie json.
Token zawiera informacje o pewnych stwierdzeniach o jego posiadaczu nazwanych claimami.
Takie stwierdzenie to na przyklad informacja, ¿e uzytkownik jest w roli admina.
Tokeny s¹ generowane po stronie serwera przy uzyciu klucza prywatnego lub przy uzyciu kombinacji klucza prywantego i publicznego.
Klient mo¿e u¿yc tokena aby udowodniæ, ¿e jest zalogowany jako administrator.
Serwer generuj¹c taki token podpisuje go kluczem prywatnym, przez co póŸniej mo¿e zweryfikowaæ czy dany token wyslany od klienta jest zgodny z kluczem, który posiada serwer.
Serwer robi to po to aby wykluczyæ próbe autentykacji nieprawid³owym tokenem.

Typowa autentykacja przy logowaniu wygl¹da nastêpuj¹co:

Uzytkownik wysy³a zapytanie z akcj¹ typu POST, gdzie podaje swój email i has³o. 
Aplikacja, czy te¿ serwer, sprawdza poprawnoœæ has³a za pomoc¹ hashu oraz czy taki u¿ytkownik istnieje w bazie.
Jeœli dane s¹ poprawne, serwer generuje Token zawieraj¹cy claimy i wysy³a go u¿ytkownikowi. 
Klient po otrzymaniu tokena JWT jest w stanie autentykowaæ siê przy wysy³aniu nastêpnych zapytañ poprzez umieszczenie tokena JWT w nag³ówku autoryzacji.
Serwer sprawdza, czy dany token nie wygas³ oraz czy klucz prywatny zgadza siê z wartoœci¹ tokena.

Ka¿dy token JWT jest podzielony na 3 czeœæi.
1. Nag³ówek - zawiera informacje jaki algorytm zosta³ u¿yty do wygenerowania podpisu
2. Payload - zbiór claimów, które zawieraj¹ informacje o posiadaczu tokena
3. Podpis - s³u¿y do sprawdzenia poprawnoœci tokena

Jak dodaæ Jwt do aplikacji. W pliku appsettings.json dodajemy:

  "Authentication": {
    "JwtKey": "PRIVATE_KEY_DONT_SHARE",
    "JwtExpireDays": 15,
    "JwtIssuer": "http://restaurantapi.com"
  },

Nastêpnie tworzymy klasê, która bêdzie reprezentowaæ te ustawienia:

    public class AuthenticationSettings
    {
        public string JwtKet { get; set; }
        public int JwtExpireDays { get; set; }
        public string JwtIssuer { get; set; }
    }


W klasie startup musimy skonfigurowaæ te ustawienia.

W metodzie Configure:

    app.UseAuthentication();

W metodzie ConfigureServices:

    var authenticationSettings = new AuthenticationSettings();

    Configuration.GetSection("Authentication").Bind(authenticationSettings); // wten sposob mozna dostac sie do ustawien z pliku appsettings.json

    services.AddAuthentication(option =>
    {
        option.DefaultAuthenticateScheme = "Bearer";
        option.DefaultScheme = "Bearer";
        option.DefaultChallengeScheme = "Bearer";
    }).AddJwtBearer(cfg =>
    {
        cfg.RequireHttpsMetadata = false;
        cfg.SaveToken = true;
        cfg.TokenValidationParameters = new TokenValidationParameters
        {
            ValidIssuer = authenticationSettings.JwtIssuer,
            ValidAudience = authenticationSettings.JwtIssuer,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(authenticationSettings.JwtKey)),
        };
    });

Metoda w AccountService do wygenerowania tokenu: 

public string GenerateJwt(LoginDto dto)
{
    var user = context.Users
        .Include(u=>u.Role)
        .FirstOrDefault(u => u.Email == dto.Email);
    if(user == null)
    {
        throw new BadRequestException("Invalid username or password");
    }
    var result = hasher.VerifyHashedPassword(user, user.PasswordHash, dto.Password);
    if(result == PasswordVerificationResult.Failed)
    {
        throw new BadRequestException("Invalid username or password");
    }

    var claimes = new List<Claim>()
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
        new Claim(ClaimTypes.Name, $"{user.FirstName} {user.LastName}"),
        new Claim(ClaimTypes.Role, user.Role.Name),
        new Claim("DateOfBirth", user.DateOfBirth.Value.ToString("yyyy-MM-dd")),
        new Claim("Nationality", user.Nationality)
    };

    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(authenticationSettings.JwtKey));
    var cred = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
    var expires = DateTime.Now.AddDays(authenticationSettings.JwtExpireDays);

    var token = new JwtSecurityToken(authenticationSettings.JwtIssuer,
        authenticationSettings.JwtIssuer,
        claimes,
        expires: expires,
        signingCredentials: cred);

    var tokenHandler = new JwtSecurityTokenHandler();
    return tokenHandler.WriteToken(token);

}

I w klasie kontrolera:

[HttpPost("login")]
public ActionResult Login([FromBody] LoginDto dto)
{
    string token = service.GenerateJwt(dto);
    return Ok(token);   
}

Je¿eli u¿ytkownik wprowadzi swój token w nag³ówku zapytania, to w kontrolerze mo¿emy uzyskiwaæ informacje o u¿ytkowniku z claimów wiêc w ten sposób wiemy, kto wysy³a zapytanie na serwer.
Dziêki temu, ¿e mo¿emy zidentyfikowaæ u¿ytkownika, mo¿emy równie¿ zautoryzowaæ u¿ytkownika do wykonania jakiejœ akcji na serwerze. 


########################################################################################################################################################################################################################################################

AUTORYZACJA

Autoryzacja jest to sprawdzenie, czy dany u¿ytkownik ma dostêp do wykonania jakiejœ akcji czy nie.

W ASP.NET Core wyró¿niamy trzy podstawowe typy autoryzacji:
-Prosta autoryzacja na podstawie roli uzytkownika
-Autoryzacja na podstawie informacji w claimie zawartym w tokenie Jwt
-Customowa polityka zdefiniowana w dowolny przez nas sposób

Aby dodaæ autoryzacje trzeba w klasie startup w metodzie configure dodaæ wywolanie metody app.UseAutorization.
Metode t¹ trzeba wywo³awaæ pomiêdzy app.UseRouting oraz app.UseEndpoints
Czyli najpierw musimy zmapowaæ akcje w kontrolerze, pozniej zautoryzowac uzytkownika i jezeli autoryzacja przebiegnie poprawnie, to wykonaæ dan¹ akcjê.
Oprócz tego musimy dodaæ autoryzacjê na poziomie konkretnej akcji lub kontrolera.


[HttpGet]
[Authorize]
public ActionResult<IEnumerable<RestaurantDto>> GetAll()
{
    var restaurantsDto = restaurantService.GetAll();

    return Ok(restaurantsDto);
}
Je¿eli chcemy aby pobranie listy wszystkich restauracji bylo mozliwe tylko dla zalogowanych uzytkownikow.
Dziêki dodaniu atrybutu [Authorize] aplikacja sprawdzi automatycznie, czy naglowek zapytania zawiera odpowiedni token. 

Teraz przy zapytaniu uzytkownik musi podac token w naglowku zapytania.

Ten sam atrybut mo¿emy na³o¿yæ na poziomie ca³ego kontrolera.

Je¿eli majac atrybut na poziomie calego kontrolera chcemy aby jakas akcja nie miala autoryzacji, to mozemy dodac do niej atrybut [AllowAnonymous]


########################################################################################################################################################################################################################################################

AUTORYZACJA ROL¥ UZYTKOWNIKA

Do autoryzowania rol¹ u¿ytkownika mo¿emy u¿yc atrybut [Authorize] z konstruktorem, który zawiera property o nazwie Role np:

[HttpPost]
[Authorize(Roles = "Admin, Menager")]
public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
{
    int id = restaurantService.Create(dto);

    return Created($"/api/restaurant/{id}", null);
}

Teraz do tej akcji maj¹ dostêp u¿ytkownicy, którzy maj¹ rolê Admin lub Manager. Aby to zadzia³o token musi zawieraæ claim z rol¹ u¿ytkownika. 

var claimes = new List<Claim>()
{
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
    new Claim(ClaimTypes.Name, $"{user.FirstName} {user.LastName}"),
    new Claim(ClaimTypes.Role, user.Role.Name),
    new Claim("DateOfBirth", user.DateOfBirth.Value.ToString("yyyy-MM-dd")),
    new Claim("Nationality", user.Nationality)
};

########################################################################################################################################################################################################################################################

AUTORYZACJA WARTOSCIA CLAIMU

services.AddAuthorization(options =>
{
    options.AddPolicy("HasNationality", builder => builder.RequireClaim("Nationality"))
});

W ten sposób w klasie startup mo¿emy dodaæ w³asn¹ polityke, która sprawdza, czy Claim Nationality istnieje w tokenie. 
Aby u¿yc tej polityki w RestaurantController:

[HttpGet]
[Authorize(Policy = "HasNationality")]
public ActionResult<IEnumerable<RestaurantDto>> GetAll()
{
    var restaurantsDto = restaurantService.GetAll();

    return Ok(restaurantsDto);
}

Teraz akcja Get bêdzie wymaga³a, aby uzytkownik mial narodowosc w tokenie. 

Aby dodaæ do naszej polityki, ¿e dany claim musi zawieraæ konkretn¹ wartoœæ, mo¿na to zrobiæ w ten sposób:

services.AddAuthorization(options =>
{
    options.AddPolicy("HasNationality", builder => builder.RequireClaim("Nationality", "Poland", "German"));
});

########################################################################################################################################################################################################################################################

CUSTOMOWA POLITYKA AUTORYZACJI

Za³o¿my, ¿e chcielibyœmy dopuœciæ do wykonania jakiejœ akcji u¿ytkowników maj¹cych wiêcej ni¿ 20 lat.
Aby tego dokonaæ, nie mo¿na wykorzystaæ poprzednich metod autoryzacji.

Mo¿emy dodaæ politykê, w której sami okreœlimy regu³ê autoryzacji.

Aby to zrobic, najpierw tworzymy w³asn¹ klasê Requirement, która dziedziczy po klasie IAuthorizationRequirement.

namespace RestaurantAPI.Authorization
{
    public class MinimumAgeRequirement: IAuthorizationRequirement
    {
        public int MinimumAge { get; }
        public MinimumAgeRequirement(int minimumAge)
        {
            MinimumAge = minimumAge;
        }
    }
}

W tej klasie dodajemy pole, które bêdzie nasz¹ wartoœci¹ do sprawdzenia i wstrzykujemy j¹ przez konstruktor.
Nastêpnie musimy dodaæ odpowiedni Handler dla tego wymagania. 


namespace RestaurantAPI.Authorization
{
    public class MinimumAgeRequirementHandler : AuthorizationHandler<MinimumAgeRequirement>
    {
        private readonly ILogger<MinimumAgeRequirementHandler> logger;

        public MinimumAgeRequirementHandler(ILogger<MinimumAgeRequirementHandler> logger)
        {
            this.logger = logger;
        }
        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, MinimumAgeRequirement requirement)
        {
            var dateOfBirth = DateTime.Parse(context.User.FindFirst(c => c.Type == "DateOfBirth").Value);

            var userEmail = context.User.FindFirst(c => c.Type == ClaimTypes.Name).Value;

            logger.LogInformation($"User with {userEmail} with date of birth {dateOfBirth}");

            if (dateOfBirth.AddYears(requirement.MinimumAge) < DateTime.Now)
            {
                logger.LogInformation("Authorization succedded");
                context.Succeed(requirement);
            }
            else
            {
                logger.LogInformation("Authorization failed");
            }
            return Task.CompletedTask;  
        }
    }
}

Ta klasa handlera dziedziczy po klasie AuthorizationHandler, która jako parametr generyczny przyjmuje nasz Requirement.
W tej klasie musimy zaimplementowaæ metodê HandlerRequirementAsync, poniewa¿ jest ona w interfejsie. 
W tej metodzie mamy dostêp do contextu, czyli do Usera.
Je¿eli wartoœæ lat uzytkownika spelnia wymaganie, to mozemy przekazaæ wiadomoœæ o spelnieniu warunku:
context.Succeed(requirement);
Dodatkowo wstrzyknieto tutaj Logger przez Dependency Injection, aby zapisywaæ informacje o przeprowadzonej autoryzacji i o jej powodzeniu lub braku powodzenia.

Na koniec w klasie startup w COnfigureServices:

services.AddAuthorization(options =>
{
    options.AddPolicy("HasNationality", builder => builder.RequireClaim("Nationality", "Poland", "German"));
    options.AddPolicy("AtLeast20", builder => builder.AddRequirements(new MinimumAgeRequirement(20)));
});

services.AddScoped<IAuthorizationHandler, MinimumAgeRequirementHandler>();

Dodajemy nasz¹ now¹ politykê, która zawiera w³asny Requirement. Dodatkowo rejestrujemy logger w kontenerze zale¿noœci. 

########################################################################################################################################################################################################################################################

DOSTEP DO ZASOBU

Chcielibyœmy dodaæ autoryzacje osób, które utworzyly dany zasób, po to aby tylko one mog³y go modyfikowaæ
Aby to zrobiæ musimy u¿yæ drug¹ implementacjê klasy AuthorizationHandler, która przyjmuje równie¿ zasób jako parametr generyczny.
U¿ywaj¹c tej klasy mo¿emy dostaæ siê do contextu zasobu, aby sprawdziæ, czy dany u¿ytkownik utworzy³ ten zasób.

Najpierw tworzymy klasê która bêdzie reprezentowaæ wartoœæ do sprawdzenia autoryzacji

namespace RestaurantAPI.Authorization
{
    public enum ResourceOperation
    {
        Create,
        Read,
        Update,
        Delete
    }

    public class ResourceOperationRequirement : IAuthorizationRequirement
    {
        public ResourceOperation Operation { get;}

        public ResourceOperationRequirement(ResourceOperation operation)
        {
            Operation = operation;
        }
    }
}

Nastêpnie tworzymy handler, który bêdzie sprawdza³ czy ten requirement jest spe³niony.

namespace RestaurantAPI.Authorization
{
    public class ResourceOperationRequirementHandler : AuthorizationHandler<ResourceOperationRequirement, Restaurant>
    {
        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, ResourceOperationRequirement requirement, Restaurant restaurant)
        {
            //every user can read and create content
            if(requirement.Operation == ResourceOperation.Read ||
                requirement.Operation == ResourceOperation.Create)
            {
                context.Succeed(requirement);
            }
            //get user id
            var userId = context.User.FindFirst(c => c.Type == ClaimTypes.NameIdentifier).Value;

            //check if this user created this restaurant
            if (restaurant.CreatedByID == int.Parse(userId))
            {
                context.Succeed(requirement);
            }
            return Task.CompletedTask;
        }
    }
}

Aby sprawdziæ, czy konkretny uzytkownik doda³ dan¹ restauracjê trzeba dodaæ odpowiednie property do encji Restaurant.

public int? CreatedByID { get; set; }
public virtual User CreatedBy { get; set; }

Po dodaniu tego do encji, trzeba wykonaæ migracje na bazie danych.

W klasie startup rejestrejumy nowy Handler:

services.AddScoped<IAuthorizationHandler, ResourceOperationRequirementHandler>();

Tego handlera tak jak poprzednich nie dodajemy poprzez atrybut. Aby w kontrolerze sprawdziæ autoryzacje u¿ytkownika trzeba
- wstrzyknaæ do serwisu IAuthorizationService
- dodac handler na poziomie proby dostepu do zasobu w ten sposob:
    var authorizationResult = authorizationService.AuthorizeAsync(user, restaurant, new ResourceOperationRequirement(ResourceOperation.Update)).Result;

    if (!authorizationResult.Succeeded)
    {
        throw new ForbidException();
    }


Dziêki temu dostêp do zmian zasobu ma u¿ytkownik, który utworzy³ dany zasób.

########################################################################################################################################################################################################################################################

UserContextService

W tym momencie aby sprawdzic czy dany uzytkownik ma dostep do zasobu, przekazujemy ca³ego uzytkownika z kontrolera do metody np. w akcji Delete w ten sposób:

public ActionResult Delete([FromRoute] int id)
{
    restaurantService.Delete(id, User);

Takie rozwi¹zanie nie jest zbyt elastyczne, bo je¿eli mielibyœmy wiele takich serwisów, które potrzebowa³yby context u¿ytkownika, to za ka¿dym razem bêdziemy musieli 
zbieraæ te infromacje i przekazywaæ w kontrolerach. Lepiej bêdzie skorzystaæ z klasy HttpContextAccesor, dziêki której mo¿emy mieæ dostêp do contextu Http nawet poza kontrolerem.

Najpierw dodajemy klasê UserCOntextService, która bêdzie odpowiada³a za zwrócenie u¿ytkownika oraz jego ID.

    public interface IUserContextService
    {
        ClaimsPrincipal User { get; }
        int? GetUserId {  get; }
    }
    public class UserContextService: IUserContextService
    {
        private readonly IHttpContextAccessor httpContextAccessor;

        public UserContextService(IHttpContextAccessor httpContextAccessor)
        {
            this.httpContextAccessor = httpContextAccessor;
        }

        public ClaimsPrincipal User => httpContextAccessor.HttpContext?.User;
        public int? GetUserId => User is null ? null : (int?)int.Parse(User.FindFirst(c => c.Type == ClaimTypes.NameIdentifier).Value);
    }

Nastêpnie rejestrujemy serwis w ten sposób:             services.AddScoped<IUserContextService, UserContextService>();

Dodajemy równie¿ Accesor w ten sposób:             services.AddHttpContextAccessor();

Teraz mo¿emy w serwisie przekazaæ przez konstruktor nasz serwis:

public RestaurantService(RestaurantDbContext context, IMapper mapper, ILogger<RestaurantService> logger,
    IAuthorizationService authorizationService, IUserContextService userContextService)
{

A nastêpnie z niego korzystaæ. Dziêki temu w klasie serwis nie jesteœmy zale¿ni od kontrolera oraz od zapytania http. 


########################################################################################################################################################################################################################################################
FILTRACJA 

W tym momencie nie filtrujemy w ¿aden sposób wyników zapytañ. 
Je¿eli mielibyœmy na przyk³ad milion rekordów w bazie danych, zwracanie zawsze wszystkich by³oby nieefektywne.
Filtrowanie pozwala na znalezienie konkretnych zasobów, natomiast paginacja polega na wyœwietleniu konkretnej iloœci wyników.

Aby dodaæ filtrowanie za pomoc¹ frazy, mo¿emy to zrobiæ w ten sposób:
W kontrolerze dodajemy parametr FromQuery, który zawiera szukan¹ frazê i przekazujemy ten parametr do metody w serwisie.

[HttpGet]
public ActionResult<IEnumerable<RestaurantDto>> GetAll([FromQuery] string searchPhrase)
{
    var restaurantsDto = restaurantService.GetAll(searchPhrase);

    return Ok(restaurantsDto);
}

Nastêpnie w serwisie dodajemy where do zapytania:

public IEnumerable<RestaurantDto> GetAll(string searchPhrase)
{
    var restaurants = context.Restaurants
        .Include(r => r.Address)
        .Include(r=> r.Dishes)
        .Where(r => searchPhrase == null || (r.Name.ToLower().Contains(searchPhrase.ToLower()) 
                                            || r.Description.ToLower().Contains(searchPhrase.ToLower())))
        .ToList();

    var restaurantsDto = mapper.Map<List<RestaurantDto>>(restaurants);

    return restaurantsDto;
}

Pisz¹c warunek w Where w ten sposób dzia³a to tak, ¿e je¿eli searchPhrase == null to zwracane s¹ wszystkie rezultaty.
Je¿eli searchPhrase !=null to sprawdzamy czy Nazwa lub opis restauracji zawieraj¹ szukan¹ frazê. 

########################################################################################################################################################################################################################################################
PAGINACJA

Dodajemy klase RestaurantQuery do modeli, która zawiera input uzytkownika o tym jakie wyniki chce dostac:

public class RestaurantQuery
{
    public string SearchPhrase { get; set; }
    public int PageNumber { get; set; }
    public int PageSize { get; set; }
}

Teraz aby wyswietlic na przyklad 5 wynikow z 3 strony, musimy pomin¹æ pierwsze 10 wyników i wzi¹¿ 5 kolejnych.

ilosc rezultatow do pominiecia = pageSize*(pageNumber - 1)

Aby w entity framewor pomin¹æ pierwsz¹ jak¹œ iloœæ rezultatów musimy wywo³aæ metodê skip.
Kolejn¹ jak¹œ iloœæ elementów mo¿emy wzi¹æ za pomoc¹ metody Take.
Ca³oœæ wygl¹da nastêpuj¹co:

public IEnumerable<RestaurantDto> GetAll(RestaurantQuery query)
{
    var restaurants = context.Restaurants
        .Include(r => r.Address)
        .Include(r=> r.Dishes)
        .Where(r => query.SearchPhrase == null || (r.Name.ToLower().Contains(query.SearchPhrase.ToLower()) 
                                            || r.Description.ToLower().Contains(query.SearchPhrase.ToLower())))
        .Skip(query.PageSize*(query.PageNumber-1))
        .Take(query.PageSize)
        .ToList();

    var restaurantsDto = mapper.Map<List<RestaurantDto>>(restaurants);

    return restaurantsDto;
}

Je¿eli mamy wiêcej ni¿ jeden parametr zapytania to ³¹czymy te parametry za pomoc¹ operatora &:
https://localhost:44328/api/restaurant/?searchPhrase=&pageSize=3&pageNumber=2

Dodatkowo do klienta musimy zwróciæ informacje ile obiektów jest jeszcze do wyœwietlenia, jaki zakres aktualnie przegl¹da i ile jest wszystkich stron przy aktualnej wielkosci strony.
Aby to zrobiæ dodajemy nowy model z wartoœciami zwracanymi.

public class PageResult<T>
{
    public List<T> Items { get; set; }  
    public int TotalPages { get; set; }
    public int ItemFrom { get; set; }
    public int ItemTo { get; set; }
    public int TotalItemsCount { get; set; }

    public PageResult(List<T> items, int totalCount, int pageSize, int pageNumber)
    {
        Items = items;
        TotalItemsCount = totalCount;
        ItemFrom = pageSize*(pageNumber-1) + 1;
        ItemTo = ItemFrom + pageSize - 1;
        TotalPages = (int)Math.Ceiling(totalCount / (double) pageSize);
    }
}

Klasa ta zaweira typ generyczny T, poniewa¿ chcielibyœmy aby by³a ona reu¿ywalna w aplikacji. 
Aby zaokr¹gliæ wartoœæ w górê u¿ywamy metody Math.Ceiling 

Nastêpnie zmieniamy metode GetAll w serwisie aby zwróciæ odpowiedni wynik z zapytania.

public PageResult<RestaurantDto> GetAll(RestaurantQuery query)
{
    var baseQuery = context.Restaurants
                        .Include(r => r.Address)
                        .Include(r => r.Dishes)
                        .Where(r => query.SearchPhrase == null || (r.Name.ToLower().Contains(query.SearchPhrase.ToLower())
                                                            || r.Description.ToLower().Contains(query.SearchPhrase.ToLower())));

    var restaurants = baseQuery
        .Skip(query.PageSize*(query.PageNumber-1))
        .Take(query.PageSize)
        .ToList();

    var restaurantsDto = mapper.Map<List<RestaurantDto>>(restaurants);

    var result = new PageResult<RestaurantDto>(restaurantsDto, baseQuery.Count(), query.PageSize, query.PageNumber);

    return result;
}

Na koniec musimy zwalidowaæ nasz model, aby uchronic program przed tym, ¿e u¿ytkownik wprowadzi na przyk³ad ujemn¹ wartoœæ pageNumber, lub zerow¹ wartoœæ pageSize itp. 
Mo¿emy to zrobiæ uzywajac FluentVaildation.

public class RestaurantQueryValidator: AbstractValidator<RestaurantQuery>
{
    private int[] allowedPageSizes = new[] { 5, 10, 15 };  
    public RestaurantQueryValidator()
    {
        RuleFor(r => r.PageNumber).GreaterThanOrEqualTo(1);
        RuleFor(r => r.PageSize).Custom((value, context) =>
        {
            if(!allowedPageSizes.Contains(value))
            {
                context.AddFailure("PageSize", $"PageSize must in [{string.Join(",", allowedPageSizes)}]");
            }
        });
    }
}

services.AddScoped<IValidator<RestaurantQuery>, RestaurantQueryValidator>();

########################################################################################################################################################################################################################################################
SORTOWANIE

Chcielibyœmy dodaæ u¿ytkownikowi sortowanie po dowolnej kolumnie i w którymœ kierunku (malej¹co lub rosn¹co)
Aby to zrobiæ trzeba zmieniæ model zapytania od klietna i dodaæ do niego dwa nowe pola:

public class RestaurantQuery
{
    public string SearchPhrase { get; set; }
    public int PageNumber { get; set; }
    public int PageSize { get; set; }
    public string SortBy { get; set; }
    public SortDirection SortDirection { get; set; }
}

SortDirection przyjmuje 2 wartoœci Asc oraz Desc.
Nastêpnie w metodzie GetAll w ServiceRestaurant dodajemy sortowanie w ten sposób:
//jezeli uzytkownik chce posortowac rezultaty
if(!string.IsNullOrEmpty(query.SortBy))
{
    nowy slownik ktory przyporzadkowuje nazwe kolumny do odpowiedniej metody, która bêdzie uzyta w OrderBy
    var columnsSelector = new Dictionary<string, Expression<Func<Restaurant, object>>>
    {
        { nameof(Restaurant.Name), r=>r.Name},
        { nameof(Restaurant.Description), r=>r.Description},
        { nameof(Restaurant.Category), r=>r.Category}
    };
    var selectedColumn = columnsSelector[query.SortBy];

    baseQuery = query.SortDirection == SortDirection.Asc 
        ? baseQuery.OrderBy(selectedColumn) 
        : baseQuery.OrderByDescending(selectedColumn);
}

W RestaurantQueryValidator dodajemy now¹ walidacjê, która bêdzie umo¿liwiaæ sprawdzenie czy uzytkownik wproadzi³ poprawne wartoœci

RuleFor(r => r.SortBy)
    .Must(value => string.IsNullOrEmpty(value) || allowedSortByColumnNames
    .Contains(value))
    .WithMessage($"Sort by is optional, or must be in [{string.Join(",", allowedSortByColumnNames)}]");

Kolejnoœc operacji w IQueryable:
1.Odfiltrowanie (.Where())
2.Posortowanie (.OrderBy())
3.Pominiecie (.Skip())
4.Wziecie rezultatow (.Take())

########################################################################################################################################################################################################################################################
Dodanie polityki CORS

Domyœlnie poprzez politykê CORS dostêp do zasobów naszej bazy jest zablokowany dla klientów z przegl¹darek.
Aby to zmieniæ mo¿na dodaæ politykê, w której mo¿na zdefiniowaæ jakie adresy hostów chcemy dopuszczaæ do pobierania zasobów API.
Dodanie polityki CORS jest proste i robi siê to w ten sposób w klasie Startup:
Adresy hostów mo¿na dodaæ do klasy appsettings.json   
"AllowedOrigins": "hhtp://localhost:8080",

Startup//ConfigureServices//
services.AddCors(options =>
{
    options.AddPolicy("FrontEndClient", builder =>
    {
        builder.AllowAnyMethod()
        .AllowAnyHeader()
        .WithOrigins(Configuration["AllowedOrigins"]);
    });
});

Startup//Configure//
app.UseCors("FrontEndClient");


########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################