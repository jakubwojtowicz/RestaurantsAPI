########################################################################################################################################################################################################################################################
Utworzenie migracji i zaktualizowanie bazy danych:

add-migration <Nazwa>

update-database



########################################################################################################################################################################################################################################################

Dependency Injection:

* Dodanie zale¿noœci Dependency Injection
* AddSingleton - mamy pewnoœæ, ¿e dana zale¿noœæ zosta³a utworzona tylko raz podczas trwania aplikacji.
* AddScoped - na jedno zapytanie bêdziemy mieæ jedn¹ instancje danego serwisu            
* AddTransient - obiekty bêd¹ tworzone za ka¿dym razem, kiedy odwo³ujemy siê do nich przez konstruktor.

services.AddScoped<IWeatherForecastService, WeatherForecastService>();

Dodajemy te zale¿noœci w metodzie ConfigureServices.

########################################################################################################################################################################################################################################################

ATRYBUTY

[Route("api/restaurant")]

To jest atrybut kontrolera, który s³u¿y do tego aby mo¿liwe by³o po³¹czenie zapytania z odpowiedni¹ akcj¹.
Dziêki temu, ¿e dodaliœmy api/restaruant, mo¿emy dodawaæ te¿ inne kontrolery, a nie tylko restaurant.

 * Dziêki atrybutowi Route mo¿emy dodaæ kolejny Get do naszego kontrolera. Bez tego by³by wyj¹tek, poniewa¿
 * program musi wiedzieæ do czego ma siê odnieœæ przy zapytaniu. Teraz nowy get bêdzie dostêpny pod œcie¿k¹
        [HttpGet]
        [Route("currentDay")] ->  /weatherforecast/currentDay


 * Inna metod¹ zmiany œcie¿ki akcji jest dodanie argumentu do atrybutu HttpGet: [HttpGet("currentDay")]

########################################################################################################################################################################################################################################################

MAPOWANIE ARGUMENTOW ZAPYTAN

 * Mapowanie atrybutów, przesy³anie parametrów do akcji.
 * Dla parametró w nawiasach w metodach musimy sprecyzowaæ, sk¹d dany parametr pochodzi.
 * Parametr mo¿e pochodziæ z adresu zapytania lub z cia³a zapytania.
 * FromRoute - przekazanie poprzez œcie¿ke -> [Route("currentDay/{max}")]
 * FromQuery - przekazanie poprzez zapytanie
 * FromBody - poprzez cia³o zapytania na przyk³ad: ([FromBody] string name)
 * Parametry trzeba odpowiednio zmapowaæ, tak aby program wiedzia³ jak po³¹czyæ zapytanie z odpowiedni¹ akcj¹
 
 Sposoby zwracania statusów zapytania
 Http context to w³asnoœæ kontrolera, dziêki której mamy dostêp do zapytania jak i odpoweidzi Http


 Aby metoda zwraca³a kod musi mieæ typ taki typ zwracanej wartoœci:

    public ActionResult<string> Hello2([FromBody] string name)
    {
            HttpContext.Response.StatusCode = 401; -> pierwszy sposób 
            return $"Hello {name}"; 
            return StatusCode(401, $"Hello {name}"); -> drugi sposób Status Code
            return NotFound($"Hello {name}"); ->trzeci sposób poprzez zwrocenie metody
    }

########################################################################################################################################################################################################################################################

MAPOWANIE DO MODELI DTO

Je¿eli chcemy aby nasze API nie zwraca³o wszystkich danych z bazy, poniewa¿ na przyk³ad s¹ to poufne dane, to tworzymy Modele np RestaurantDto, w którym zawieramy tylko te informacje, które maj¹ trafiæ do klienta API.


Aby mapowaæ obiekty bazodanowe na modele Dto mo¿na u¿yæ AutoMappera. NuGet -> AutoMapper.Extensions.Microsoft.DependencyInjcetion
Nastêpnie tworzymy klasê do mapowania, która dzidziczy po klasie Profile:

    public class RestaurantMappingProfile: Profile
    {
        public RestaurantMappingProfile()
        {
            CreateMap<Restaurant, RestaurantDto>()
                .ForMember(m => m.City, c => c.MapFrom(s => s.Address.City))
                .ForMember(m => m.Country, c => c.MapFrom(s => s.Address.Country));

            CreateMap<Dish, DishDto>();
        }
    }

    **te pola z klas które s¹ identyczne w obu klasach s¹ mapowane automatycznie**

    Po utworzeniu klasy, dodajemy Mappera do kontrolera:

    private readonly IMapper mapper;

    public RestaurantController(RestaurantDbContext dbContext, IMapper mapper)
    {
        _context = dbContext;
        this.mapper = mapper;
    }

    Mapowanie w metodzie Get:

    [HttpGet]
    public ActionResult<IEnumerable<RestaurantDto>> GetAll()
    {
        var restaurants = _context.Restaurants.ToList();

        var restaurantsDto = mapper.Map<List<RestaurantDto>>(restaurants);


        return Ok(restaurantsDto);
    }

    Na koniec dodajemy service w klasie Startup:

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        services.AddDbContext<RestaurantDbContext>();
        services.AddScoped<RestaurantSeeder>();
        services.AddAutoMapper(this.GetType().Assembly);
    }

    Aby zawrzec tez inne klasy w naszych wynikach musimy uzyc w LINQ Include:

    var restaurant = _context
                .Restaurants
                .Include(r => r.Address)
                .Include(r => r.Dishes)
                .FirstOrDefault(x => x.Id == id);


########################################################################################################################################################################################################################################################

    Dodawanie elementu do bazy za pomoc¹ czasownika POST. Utworzenie encji za pomoc¹ modelu CreateDto.

    [HttpPost]
    public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
    {
        var restaurant = mapper.Map<Restaurant>(dto);
        _context.Restaurants.Add(restaurant);
        _context.SaveChanges();

        return Created($"/api/restaurant/{restaurant.Id}", null);
    }

    W ten sposób mo¿emy dodaæ metodê do wstawiania nowych danych do bazy.
    Zosta³a utworzona nowa klasa CreateRestaurantDto, której u¿ytkownik wpisuje obiekt w ciele zapytania.
    Zosta³o dodane nowe mapowanie w klasie MappingProfile, dziêki któremu odbywa siê mapowanie obiektu przekazanego przez u¿ytkownika, na obiekt który jest dodawany do bazy.
    Zwracamy tutaj odpowiedz typu Created oraz dajemy link do nowo utworzonej encji.


########################################################################################################################################################################################################################################################

    Walidacja

    Aby walidowaæ dane, które wprowadza u¿ytkownik poprzez zapytanie, najlepiej dodawaæ atrybuty w klasie do tworzenia obiektu przez uzytkownika API.
    [Required] - atrybut, który okreœla, ¿e to pole jest wymagane,
    [MaxLength()] - atrybut, który okreœla, ¿e to pole ma jak¹œ maksymaln¹ d³ugoœæ
    Inne atrybuty:
    [CreditCard] 
    [Compare("Inne pole klasy")]
    [EmailAdress]
    [Phone]
    [Range(minValue, maxValue)]
    [RegularExpression(pattern)]

    public class CreateRestaurantDto
    {
        [Required]
        [MaxLength(25)]
        public string Name { get; set; }
        public string Description { get; set; }
        public string Category { get; set; }
        public bool HasDelivery { get; set; }
        public bool ContactEmail { get; set; }
        public bool ContactPhone { get; set; }
        [Required]
        [MaxLength(50)]
        public string City { get; set; }
        public string Country { get; set; }
        [Required]
        [MaxLength(50)]
        public string Region { get; set; }
    }

    W ten sposób nastêpnie mo¿emy sprawdziæ czy wprowadzono poprawne dane i ewnetualnie wys³aæ BadRequest

    [HttpPost]
    public ActionResult CreateRestaurant([FromBody] CreateRestaurantDto dto)
    {
        if(ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var restaurant = mapper.Map<Restaurant>(dto);
        _context.Restaurants.Add(restaurant);
        _context.SaveChanges();

        return Created($"/api/restaurant/{restaurant.Id}", null);
    }

########################################################################################################################################################################################################################################################

    Refaktor kontrolera

    Kontroler nie powininien zawieraæ du¿o logiki. Powinien on zawieraæ odebranie zapytania, ewentualn¹ walidacjê i przes³anie zapytania do jakiegoœ serwisu, który obs³uguje dane zapytanie. 
    Serwis wstrzykujemy poprzez Dependency Injection.

########################################################################################################################################################################################################################################################
    
    Usuwanie elementów

    Usuwanie elementów realizuje czasownik Delete

    //RestaurantController
    [HttpDelete("{id}")]
    public ActionResult Delete([FromRoute] int id)
    {
        var isDeleted = restaurantService.Delete(id);

        if(isDeleted)
        {
            return NoContent();
        }
        else
        {
            return NotFound();
        }
    }

    //RestaurantService
    public bool Delete(int id)
    {
        var restaurant = context
            .Restaurants
            .FirstOrDefault(x => x.Id == id);

        if (restaurant is null) return false;
        context.Restaurants .Remove(restaurant);
        context.SaveChanges();
        return true;
    }


########################################################################################################################################################################################################################################################

Loger

Aby mieæ pe³ny wgl¹d na to co dzia³o siê na serwerze, musimy dodaæ logowanie do aplikacji. Chodzi o zapis informacji w formie tekstowej np. do pliku tekstowego. 
Do naszego api dodamy biblioteke nlog.
nuget -> NLog.Web.AspNetCore

Trzeba dodaæ plik nlog.config, który konfiguruje logera.


Dodaktowo w klasie Program.cs dodajemy UseNLog:


        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                })
                .UseNLog();

Nastêpnie dodajemy logger do serwisu i wykonujemy jakiœ log w którejœ akcji.

    public class RestaurantService:IRestaurantService
    {
        private readonly RestaurantDbContext context;
        private readonly IMapper mapper;
        ***
        private readonly ILogger<RestaurantService> logger;

        public RestaurantService(RestaurantDbContext context, IMapper mapper, ILogger<RestaurantService> logger)
        {
            this.context = context;
            this.mapper = mapper;
            ***
            this.logger = logger;
        }

        public bool Delete(int id)
        {
        ***
            logger.LogWarning($"Restaurant with id: {id} DELETE action invoked");
            var restaurant = context
                .Restaurants
                .FirstOrDefault(x => x.Id == id);

            if (restaurant is null) return false;
            context.Restaurants.Remove(restaurant);
            context.SaveChanges();
            return true;
        }



########################################################################################################################################################################################################################################################

Error handling middleware

Aby z³apaæ b³¹d w aplikacji i w pe³ni wykorzystaæ logger dla wyj¹tków musimy ³apaæ wyj¹tki i w ramach ich obs³ugi zapisywaæ informacje poprzez logger. 
Zamiast dodawaæ try catch do wszystkich mo¿liwych miejsc, gdzie mo¿e wyst¹piæ wyj¹tek, mo¿emy stworzyæ w³asny middleware i dodaæ go do klasy stratup. 
Dziêki temu ka¿de zapytanie bêdzie procesowany przez ten middleware.

Tworzymy klasê Middleware, która implementuje interfejst IMiddleware.

    public class ErrorHandlingMiddleware : IMiddleware
    {
        public ILogger<ErrorHandlingMiddleware> logger;
        public ErrorHandlingMiddleware(ILogger<ErrorHandlingMiddleware> logger)
        {
            this.logger = logger;
        }

        public async Task InvokeAsync(HttpContext context, RequestDelegate next)
        {
            try
            {
                await next.Invoke(context);
            }
            catch(Exception e)
            {
                logger.LogError(e, e.Message);

                context.Response.StatusCode = 500;
                await context.Response.WriteAsync("Something went wrong...");
            }
        }
    }

    Klasa ta ma blok try catch, który próbuje wywo³aæ nastêpny middleware asynchronicznie. W obs³udze b³êdu logujemy b³¹d i wysy³amy odpowiedŸ do klienta z ustawieniem statusu na 500.

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        services.AddDbContext<RestaurantDbContext>();
        services.AddScoped<RestaurantSeeder>();
        services.AddScoped<IRestaurantService, RestaurantService>();
        services.AddAutoMapper(this.GetType().Assembly);
        services.AddScoped<ErrorHandlingMiddleware>();
    }

    W metodzie ConfigureServices w klasie Startup dodajemy nasz middleware.

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env, RestaurantSeeder seeder)
    {

        seeder.Seed();

        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseMiddleware<ErrorHandlingMiddleware>();

        app.UseHttpsRedirection();

        app.UseRouting();

        app.UseAuthorization();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }

    W metodzie Configure dodajemy nasz middleware na pocz¹tku przep³ywu zapytania.

########################################################################################################################################################################################################################################################

Customowe b³êdy API

W tym momencie ³apanie b³êdów API, np gdy dany zasób nie istnieje, by³o realizowane poprzez controller.
Controller wywo³uje metode z serwisu, która zwraca informacje o b³êdzie, a nastêpnie controller zwraca informacje do u¿ytkownika API.
Ta implementacja wprowadza zale¿noœæ pomiêdzy tymi dwoma klasami kontrolera i serwisu.
Aby pozbyæ siê tego powi¹zania, w serwisie mo¿na wyrzucaæ wyjatki oraz je przechwytywaæ w naszej klasie ErrorHandlingMiddleware.

**Nasze customowe wyj¹tki mo¿emy dodawaæ w folderze Exceptions. Wyjatek musi dziedziczyæ po klasie Exception oraz wywo³ywaæ konstruktor bazowy.

public class NotFoundException:Exception
{
    //base(message) - wywo³anie konstruktora bazowego
    public NotFoundException(string message) : base (message)
    {
            
    }
}

**Nastêpnie w klasie service wyrzucamy wyj¹tek:

public void Update(int id, UpdateRestaurantDto dto)
{
    var restaurant = context
        .Restaurants
        .FirstOrDefault(x => x.Id == id);
    if (restaurant is null) 
        throw new KeyNotFoundException("Restaurant not found");

    restaurant.Name = dto.Name;
    restaurant.Description = dto.Description;
    restaurant.HasDelivery = dto.HasDelivery;
    context.SaveChanges();
}

**Teraz nasza metoda w kontrolerze mo¿e byæ krótsza np:

[HttpPut("{id}")]
public ActionResult Update([FromRoute] int id, [FromBody] UpdateRestaurantDto dto)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }

    restaurantService.Update(id, dto);

    return Ok();
}

**Na koniec obs³ugujemy wyj¹tek w ErrorHandlingMiddleware

public async Task InvokeAsync(HttpContext context, RequestDelegate next)
{
    try
    {
        await next.Invoke(context);
    }
    catch(NotFoundException notFoundException)
    {
        context.Response.StatusCode = 404;
        await context.Response.WriteAsync(notFoundException.Message);
    }
    catch(Exception e)
    {
        logger.LogError(e, e.Message);

        context.Response.StatusCode = 500;
        await context.Response.WriteAsync("Something went wrong...");
    }
}

**Dodatkowo w naszym kontrolerze powtarza siê walidacja modelu w wielu metodach. Aby pozbyæ siê tych powtórzeñ dodajemy atrybut [ApiController]

namespace RestaurantAPI.Controllers
{
    [Route("api/restaurant")]
    [ApiController]
    public class RestaurantController : ControllerBase
    {
        private readonly IRestaurantService restaurantService;

        public RestaurantController(IRestaurantService restaurantService)
        {
            this.restaurantService = restaurantService;
        }

        ...

Dziêki temu kawa³ek kodu :

if (!ModelState.IsValid)
{
    return BadRequest(ModelState);
}

jest wywo³ywany automatycznie.



########################################################################################################################################################################################################################################################

Dokumentacja API - Swagger

Do naszego API przyda³aby siê dokumentacja dostêpnych akcji. Do tego mo¿e pos³u¿yæ Swagger. 
Je¿eli ktoœ inny ni¿ my mia³by stworzyæ frontend do naszego API, to musielibyœmy mu dostarczyæ informacje, jakie s¹ metody w naszym API oraz jak je wywo³aæ.
Swagger tworzy automatyczn¹ dokumentacje API na podstawie akcji w kontrolerach API.
Nuget -> Swashbuckle.AspNetCore

W klasie Startup w metodzie Configure Servies dodajemy:

services.AddSwaggerGen();

W metodzie configure:

...

app.UseHttpsRedirection();

app.UseSwagger();
app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "Restaurant API"));

...

Dziêki UseSwagger() zostanie wygenerowany plik json z dokumentacja
Dziêki UseSwaggerUI() zostanie wygenerowany interfejs u¿ytkownika, która bêdzie zawiera³ dokumentacje z wczeœniej stworzonego pliku json.

Aby dostaæ siê do interfejsu w przegl¹darce wpisujemy adres hosta ze œcie¿k¹ swagger np: https://localhost:44328/swagger.

Dziêki Swaggerowi ka¿dy kto chcia³by korzystaæ z naszego API mo¿e siê dowiedzieæ poprzez wygenrowany interfejs.

########################################################################################################################################################################################################################################################

Zarz¹dzanie podencjami

Je¿eli chcielibyœmy dodaæ kontroler do encji Dish to moglibyœmy to zrobiæ dodaj¹c adres api/dish. 
Natomiast problem z tym, jest taki, ¿e Dish nie mo¿e istnieæ bez restauracji, wiêc nie za bardzo mo¿na tak zrobiæ.
Aby to zrobiæ odpowiednio ustawiamy œcie¿kê api/restaurant/{restaurantId}/dish.


########################################################################################################################################################################################################################################################

AUTENTYKACJA

W tym momencie ka¿dy u¿ytkownik API mo¿e wykywaæ ka¿d¹ akcjê w bazie danych. Mog¹ oni usuwaæ zasoby nawet jeœli ich nie stworzyli.
Nie da³oby siê sprawdziæ jaki u¿ytkownik wys³a³ jakie zapytanie. 
Autentykacja to proces polegaj¹cy na potwierdzeniu to¿samoœci podmiotu bior¹cego udzia³ w komunikacji.
Ma za zadanie okreœliæ, czy u¿ytkownik jest tym, za kogo siê podaje. 

W przypadku autentykacjji elektronicznej stosuje siê:
**metody oparte no tokenach, 
**klucze prywatne
**has³a

Kategorie procesów autentykacji:
1. Coœ co masz (Token, telefon z oprogramowaniem, karta)
2. Coœ czym jesteœ (g³os, twarz, odcisk palca)
3. Coœ co wiesz (PIN, Has³o, pytanie pomocniczne)

W aplikacjach wra¿liwych czêsto stosuje siê autentykacje dwusk³adnikow¹. 

W tej aplikacji zostan¹ u¿yte has³a. 

Role:
*User - zwyk³y u¿ytkownik, który mo¿e tylko przegl¹daæ informacje o restauracjach 
*Menager - mo¿e zarz¹dzaæ swoimi restauracjami 
*Administrator - osoba, która mo¿e nadawaæ uprawnienia innym u¿ytkownikom

Aby dodaæ odpowiednie role i informacje musimy dodaæ odpowiednie tabele do bazy danych.

    public class User
    {
        public int Id { get; set; }
        public string Email { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime? DateOfBirth { get; set; }
        public string Nationality { get; set; }
        public string PasswordHash { get; set; }
        public int RoleId { get; set; }
        public virtual Role Role { get; set; }

    }

    public class Role
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

Role powinny mieæ zawsze ustalone wartoœci w bazie danych dlatego trzeba je zaseedowaæ.

########################################################################################################################################################################################################################################################

Hashowanie hase³.

Musimy byæ pewni, ¿e w przypadku w³amania do bazy danych, has³a u¿ytkowników nigdy nie zostan¹ ujawnione.
W ¿adnym wypadku nie chcemy przechowywaæ hase³ u¿ytkowników w postaci tekstu.
Wielu u¿ytkowników korzysta z tych samych hase³ na ró¿nych stronach. 
Przez to jest ryzyko, ¿e ich inne konta mog¹ byæ zaatakowane po ujawnienia hase³ w naszym API.

Hashowanie to powszechne podejscie do bezpiecznego zabezpieczenia hasla.
Hashowanie jest jednokierunkowe, czyli z wartosci po wykonaniu funkcji hashuj¹cej, nie uzyskamy ju¿ wartoœci pocz¹tkowej.

Gdy u¿ytkownik zarejestruje konto, jego has³o jest przechowywane jako hash w bazie danych.
Nastêpnie przy próbie zalogowania, wpisane has³o bêdzie ponownie zahashowane i porównane z tym, które jest ju¿ w bazie danych.
Jest wiele dostepnych paczek do wykonywania hashowania hase³.
W ASPNetCore.Identity istnieje klasa PasswordHasher, która s³u¿y do tego celu.
Klasa PasswordHasher zawiera dwie metody:
1.HasPassword do wykonania funkcji Hashuj¹cej dla danego u¿ytkownika.
2.VerifyHashedPassword, która dla u¿ytkownika, has³a z bazy i has³a wpisanego sprawdza, czy podano prawid³owe has³o.

Aby korzystaæ z klasy PasswordHasher trzeba j¹ zarejestrowaæ w kontrolerze zale¿noœci w klasie startup.

 services.AddScoped<IPasswordHasher<User>, PasswordHasher<User>>();

 U¿ycie hashera:

     public class AccountService: IAccountService
    {
        private readonly RestaurantDbContext context;
        private readonly IPasswordHasher<User> hasher;

        public AccountService(RestaurantDbContext context, IPasswordHasher<User> hasher)
        {
            this.context = context;
            this.hasher = hasher;
        }
        public void RegisterUser(RegisterUserDto dto)
        {
            var newUser = new User()
            {
                Email = dto.Email,
                DateOfBirth = dto.DateOfBirth,
                Nationality = dto.Nationality,
                RoleId = dto.RoleId
            };
            var hashedPassword = hasher.HashPassword(newUser, dto.Password);

            newUser.PasswordHash = hashedPassword;

            context.Users.Add(newUser); 
            context.SaveChanges();
        }
    }


########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################

########################################################################################################################################################################################################################################################